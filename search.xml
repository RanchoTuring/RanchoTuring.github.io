<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十大排序算法比较</title>
      <link href="/2019/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h2><p> <a href="https://www.nowcoder.com/discuss/85719" target="_blank" rel="noopener">原作者：opooc</a></p><h2 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h2><p><strong>时间复杂度：</strong></p><blockquote><p>反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。(下面用logN表示 log以2为底，N的对数)     </p></blockquote><p><strong>空间复杂度：</strong></p><blockquote><p>是指算法在计算机内执行时，所需额外开辟的空间。     </p></blockquote><p><strong>指标：</strong> </p><blockquote><p>同时间复杂度。     </p></blockquote><p><strong>常数项：</strong></p><blockquote><p>与N的大小无关的操作。     </p></blockquote><p><strong>稳定性：</strong></p><blockquote><p>(1)稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>(2)不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。     </p></blockquote><h2 id="2、算法分类"><a href="#2、算法分类" class="headerlink" title="2、算法分类"></a>2、算法分类</h2><blockquote><p><strong>十大经典排序算法可以分为两大类：</strong><br>0、非线性时间排序：通过比较来决定元素间的相对次序。时间复杂度最快为O(logN)<br>1、线性时间排序：通过创建有序的空间，将元素按照一定的规则放入有序空间，再依次取出。以空间来换取时间，可以突破O(logN)     </p></blockquote><ul><li>非线性时间排序         <ol><li>比较排序                 <ul><li>冒泡排序                     </li><li>快速排序                     </li></ul></li><li>插入排序                 <ul><li>插入排序                     </li><li>希尔排序                     </li></ul></li><li>选择排序                 <ul><li>选择排序                     </li><li>堆排序                     </li></ul></li><li>归并排序                 <ul><li>二路归并排序                     </li><li>多路归并排序                     </li></ul></li></ol></li><li>线性时间排序         <ol><li>计数排序             </li><li>堆排序             </li><li>基数排序             </li></ol></li></ul><h2 id="3、各算法的时间复杂度"><a href="#3、各算法的时间复杂度" class="headerlink" title="3、各算法的时间复杂度"></a>3、各算法的时间复杂度</h2><table><thead><tr><th>排序算法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>冒泡排序(外层优化)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>冒泡排序(外+内优化)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>快速排序(经典)</td><td>O(NlogNNlogN)</td><td>O(N2N2)</td><td>O(NlogNNlogN)</td><td>O(logNlogN)</td><td style="text-align:left">不稳定</td></tr><tr><td>快速排序(随机)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(logNlogN)</td><td style="text-align:left">不稳定</td></tr><tr><td>插入排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>希尔排序</td><td>O(N1.3N1.3)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>选择排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(11)</td><td style="text-align:left">不稳定</td></tr><tr><td>堆排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(11)</td><td style="text-align:left">不稳定</td></tr><tr><td>二路归并排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NN)</td><td style="text-align:left">稳定</td></tr><tr><td>多路路归并排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NN)</td><td style="text-align:left">稳定</td></tr><tr><td>计数排序</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr><tr><td>桶排序</td><td>O(N+kN+k)</td><td>O(N2N2)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr><tr><td>基数排序</td><td>O(N∗kN∗k)</td><td>O(N∗kN∗k)</td><td>O(N∗kN∗k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr></tbody></table><h2 id="4、排序算法的实现"><a href="#4、排序算法的实现" class="headerlink" title="4、排序算法的实现"></a>4、排序算法的实现</h2><h3 id="0、通用函数及其他"><a href="#0、通用函数及其他" class="headerlink" title="0、通用函数及其他"></a>0、通用函数及其他</h3><blockquote><p>(0)、求数组长度（需要传数组，不要传数组指针）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里的注意点：在计算数组大小的时候，</span></span><br><span class="line"><span class="comment">   一定要注意传入的数组是否为数组指针，</span></span><br><span class="line"><span class="comment">   如果传入的是数组指针，sizeof后出来的值为8(64位下)，读者应注意。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(T&amp;amp; arr)</span></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(1)、交换数组两个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangee</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">/*   ^符号 即”异或“运算符，特点是与0异或，</span></span><br><span class="line"><span class="comment">  保持原值；与本身异或，结果为0。</span></span><br><span class="line"><span class="comment"> 这里可以使用位运算，交换时不用开辟额外空间。</span></span><br><span class="line"><span class="comment">  但是如果传入的'位置相同'的两个数，就不能在此函数中进行交 </span></span><br><span class="line"><span class="comment">  换。因为，自己跟自己异或后结果一定为0,就没有什么意义了。</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[b] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[a];</span><br><span class="line">arr[a] =  arr[b];</span><br><span class="line">arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> (2)、算法中的表达<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A代表平均时间复杂度</span><br><span class="line">* B代表最坏时间复杂度</span><br><span class="line">* E代表最好时间复杂度</span><br><span class="line">* 省略了O()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(3)、大数据样本下四钟最快算法的比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 数据是随机整数，时间单位是秒</span></span><br><span class="line"><span class="comment"> 数据规模|快速排序 归并排序 希尔排序 堆排序</span></span><br><span class="line"><span class="comment"> 1000万 |  0.75  1.221.773.57</span></span><br><span class="line"><span class="comment"> 5000万 |  3.78  6.299.4826.54</span></span><br><span class="line"><span class="comment"> 1亿|  7.65  13.06   18.79   61.31</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(4)、时间复杂度的大小比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> N!&gt;; x^N &gt;;...&gt;;3^N &gt;;2^N &gt;; N^x&gt;;...&gt;;N^3 &gt;;N^2&gt;;NlogN&gt;;N&gt;;logN&gt;;1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(5)数组和数组大小的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arrAndSize</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(6)初始化数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//一维 每个元素初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](<span class="number">0</span>);</span><br><span class="line"><span class="comment">//二维 每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//二维 每个一维中含N个数，N为确定的数值。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(N);</span><br><span class="line"><span class="comment">//通过动态创建的数组，要进行内存释放，否则内存将泄漏</span></span><br><span class="line"><span class="comment">//(本文中，未进行内存释放)</span></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(7)综合排序总结</p><ul><li>思考一个排序时候，考虑时间复杂度中的指标和常数项，空间复杂度，稳定性.</li></ul></blockquote><ul><li><p>代码规模，一定程度上说明了常数项的大小。（最终常数项的大小是看发生常数操作的次数）</p></li><li><p>系统的sort 方法，发现传进来的值为数值型，会使用快排，如果发现传的还有比较器，会使用归并排序</p></li><li><p><strong>归并和快排哪种更快？</strong><br>快排比归并排序的常数项要低，所以要快。</p></li><li><p><strong>为什么会有归并和快排两种呢？</strong><br>在比较的时候，使用比较器的时候，要追求一个稳定性，使用 归并排序 可以达稳定性的效果；使用快排不能够实现稳定性的效果。</p></li><li><p>面对大规模的时候，当排序量是小于等于60的时候，sort方法  会在内部使用插入排序的方法（不一定是60，是一定的规模）当数据量很低的时候，插入排序的常数项低。</p></li><li><p>在c语言中有一版，把归并排序，改成非递归，是基于工程其他考虑。</p></li></ul><blockquote><p>(8)对比两个数组是否相同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span> firstArr[],<span class="keyword">int</span> Second[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second != <span class="literal">nullptr</span>) ||(firstArr != <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len(firstArr) != len(Second)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len(firstArr); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (firstArr[i] != Second[i]) &#123;</span><br><span class="line"><span class="comment">//可以在此位置，打印错误项</span></span><br><span class="line"><span class="comment">//也可以打印整个数组查看错误项</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(9)复制数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">arrayCopy</span><span class="params">(<span class="keyword">int</span> oldArray[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oldArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* newArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i&lt;;length;i++) &#123;</span><br><span class="line">newArray[i] = oldArray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(10)产生随机数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arrAndSize <span class="title">generateRandomArr</span><span class="params">(<span class="keyword">int</span> maxSize,<span class="keyword">int</span> maxValue)</span></span>&#123;</span><br><span class="line"><span class="comment">//int arrrr =rand()%10;</span></span><br><span class="line">arrAndSize aAndS;</span><br><span class="line"><span class="keyword">int</span> size = (<span class="keyword">int</span>)((maxSize+<span class="number">1</span>) * (rand()%<span class="number">10</span>/(<span class="keyword">double</span>)<span class="number">10</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;;<span class="string">"&#123;"</span>&lt;;&lt;;size&lt;;&lt;;<span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt;; size;i++)&#123;</span><br><span class="line"><span class="comment">// 随机生成[-N,N];</span></span><br><span class="line"><span class="comment">//array[i] = (int)((maxValue +1) * (rand()%100)/(double)100) - (int)((maxValue + 1) * (rand()%100/(double)100));</span></span><br><span class="line"><span class="comment">//随机生成[0,N];</span></span><br><span class="line"> <span class="built_in">array</span>[i] = (<span class="keyword">int</span>)((maxValue +<span class="number">1</span>) * (rand()%<span class="number">10</span>)/(<span class="keyword">double</span>)<span class="number">10</span>);</span><br><span class="line"><span class="comment">//打印到底生成了什么。</span></span><br><span class="line"><span class="comment">//cout&lt;;&lt;;i&lt;;&lt;;"===="&lt;;&lt;;array[i] &lt;;&lt;;"|";</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;;&lt;;"+++++"&lt;;&lt;;endl;</span></span><br><span class="line">aAndS.size = size;</span><br><span class="line">aAndS.<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">return</span> aAndS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(11)疯狂递归 -递归master公式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 递归master公式</span></span><br><span class="line"><span class="comment"> T(N)的公式从大规模来看，不细分。</span></span><br><span class="line"><span class="comment"> T(N) = a * T(N/b)+O(n^d)</span></span><br><span class="line"><span class="comment"> N/b 是子过程数据量 ；a是子过程调用多少次；O(n^d)是出去</span></span><br><span class="line"><span class="comment"> 过程之外剩下的数据量的多少</span></span><br><span class="line"><span class="comment"> if log(b)a &gt;; d =&gt;; O(N^log(b)a)</span></span><br><span class="line"><span class="comment"> if log(b)a = d =&gt;; O(N^d *logN)</span></span><br><span class="line"><span class="comment"> if log(b)a &lt;; d =&gt;; O(N^d)</span></span><br><span class="line"><span class="comment"> 注意 多个递归的规模必须一样，否则master公式失效。</span></span><br><span class="line"><span class="comment">  例如一个规模是1/3;一个是2/3;</span></span><br><span class="line"><span class="comment"> 以下算法的时间复杂度：a = 2;b = 2;d = 0;所以时间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> arr[] ,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L ==  R) &#123;<span class="comment">//base case;</span></span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> LeftMax = process(arr, L, mid);</span><br><span class="line"><span class="keyword">int</span> RightMax = process(arr, mid+<span class="number">1</span> , R);</span><br><span class="line"><span class="keyword">return</span> (LeftMax /RightMax)?LeftMax  : RightMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInArray</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> process(arr , <span class="number">0</span> , length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(12)比较器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按照年龄降序比较器</span></span><br><span class="line"><span class="comment"> 比较器使用的时候 不和java一样，c++中的比较器要注意返回值要为bool类型，</span></span><br><span class="line"><span class="comment">  而java中的返回值可以为int类型，根据两数相减进行判断下一步的排序。</span></span><br><span class="line"><span class="comment"> 比较器第一次比较完成后，下一次在比较的时候还是会含有第一次的排号的顺序，</span></span><br><span class="line"><span class="comment">  是利用了c++中sort函数的排序稳定性.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//比较器的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照年龄升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallAge</span><span class="params">(student s1,student s2)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里返回false的时候，相当于进行了一个交换操作</span></span><br><span class="line"><span class="keyword">return</span> s2.age &gt;; s1.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照班级升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallClassId</span><span class="params">(student s1, student s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s2.classId &gt;; s1.classId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">student s1 =  &#123;<span class="string">"opooc"</span>,<span class="number">21</span>,<span class="number">100</span>&#125;;</span><br><span class="line">student s2 =  &#123;<span class="string">"cat"</span>,<span class="number">30</span>,<span class="number">105</span>&#125;;</span><br><span class="line">student s3 =  &#123;<span class="string">"dog"</span>,<span class="number">1</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s4 =  &#123;<span class="string">"daolao"</span>,<span class="number">2</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s5 =  &#123;<span class="string">"dst"</span>,<span class="number">20</span>,<span class="number">103</span>&#125;;</span><br><span class="line">student allStudent[] =&#123;s1,s2,s3,s4,s5&#125;;</span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallAge);</span><br><span class="line"><span class="comment">//上面按照年龄升序后的结果，会继续在下面的班级降序中体现出来</span></span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallClassId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(13)vector容器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个一维容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;; v;</span><br><span class="line"><span class="comment">//声明一个二维数组，里面每个一维数组大小为10(必填)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; v1[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除最后添加的元素</span></span><br><span class="line">v.pop_back();</span><br><span class="line"><span class="comment">//删除向量中迭代器指向元素</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除向量中[first,last)中元素 如下删除1234位置</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>,v.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在第零个元素前面插1</span></span><br><span class="line">v.insert(v.begin(),<span class="number">1</span>);</span><br><span class="line"><span class="comment">//在第二个元素前插2</span></span><br><span class="line">v.insert(v.begin()+<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在最后一个元素后面插的10</span></span><br><span class="line">v.insert(v.end(),<span class="number">10</span>);</span><br><span class="line"><span class="comment">//元素的个数</span></span><br><span class="line">v.size();</span><br><span class="line"><span class="comment">//清除所有元素</span></span><br><span class="line">v.clear();</span><br><span class="line"><span class="comment">//遍历整个数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;:: iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>算法描述:</p><blockquote><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></blockquote><p>动画演示:</p><p><img alt="冒泡排序" src="https://img-blog.csdn.net/20180711042751164?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p></blockquote><h4 id="1-0、简单冒泡排序"><a href="#1-0、简单冒泡排序" class="headerlink" title="1.0、简单冒泡排序"></a>1.0、简单冒泡排序</h4><blockquote><p>（交换排序;时间A:N^2 ,B:N^2 ,E:N^2 ;空间1;稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;;length - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="1-1、外层循环优化冒泡排序"><a href="#1-1、外层循环优化冒泡排序" class="headerlink" title="1.1、外层循环优化冒泡排序"></a>1.1、外层循环优化冒泡排序</h4><blockquote><p>(交换排序; 时间A:N^2 , B:N^2 , E:N; 空间1; 稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用一个flag来判断一下，当前数组是否已经有序,</span></span><br><span class="line"><span class="comment">  有序就退出循环，可以提高冒泡排序的性能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;;length; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; length -i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j]&gt;;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">flag  =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="1-2、内层循环优化冒泡排序"><a href="#1-2、内层循环优化冒泡排序" class="headerlink" title="1.2、内层循环优化冒泡排序"></a>1.2、内层循环优化冒泡排序</h4><blockquote><p>(交换排序; 时间A:N^2 , B:N^2 , E:N ; 空间1 ; 稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)完美冒泡</span></span><br><span class="line"><span class="comment">(2)再用last标记一下最后一个发生交换的数，</span></span><br><span class="line"><span class="comment">   下次可以减少循环次数。其中第一次内部循环的控制条件，单独拿出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>算法描述:</p><blockquote><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><p>动画演示:<br><img alt="快速排序" src="https://img-blog.csdn.net/20180711042825711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法流程如下：<br>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><h4 id="2-0、随机快速排序"><a href="#2-0、随机快速排序" class="headerlink" title="2.0、随机快速排序"></a>2.0、随机快速排序</h4><blockquote><p>（交换排序;时间A:NlogN,B:NlogN,E:NlogN;空间logN;不稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)in-place原地算法可以实现 把以划分值为标准，</span></span><br><span class="line"><span class="comment">       小于等于划分值的放左边并推着大于划分值的数向右走。</span></span><br><span class="line"><span class="comment">       时间复杂度O(N)空间复杂度是O（1）</span></span><br><span class="line"><span class="comment">    (2)（荷兰国旗问题）在实现把等于划分值的放中间，小于</span></span><br><span class="line"><span class="comment">        划分值的放左边，大于划分值的放右边且时间复杂度O(N)</span></span><br><span class="line"><span class="comment">        空间复杂度仍未O(1)的时候。1.当前数&lt;p左区下一个</span></span><br><span class="line"><span class="comment">        交换，左区扩，检测下一个。2、当前数等于p，检测下</span></span><br><span class="line"><span class="comment">        一个。3、当前数大于p，和右区前一个位置换，右区扩。</span></span><br><span class="line"><span class="comment">        继续检测当前换完的数。</span></span><br><span class="line"><span class="comment">    (3) 其中的空间复杂度是不得不使用的空间，用来记录每次的左右边界。</span></span><br><span class="line"><span class="comment">    (4)快速排序可以做到稳定，但是非常难，可以搜 0-1stable sort论文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">separate</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first  = left <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Second = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; Second) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, ++first, left++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, --Second, left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]==arr[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exchangee(arr, Second, right);</span><br><span class="line">    <span class="keyword">int</span> firstAndSecond[<span class="number">2</span>] = &#123;first+<span class="number">1</span>,Second&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> firstAndSecond;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> randomC = (<span class="keyword">int</span>)((rand()%<span class="number">100</span>/(<span class="keyword">double</span>)<span class="number">100</span>) * (right - left +<span class="number">1</span>));</span><br><span class="line">        exchangee(arr,left+ randomC, right);</span><br><span class="line">        <span class="keyword">int</span>* curArr  = separate(arr, left, right);</span><br><span class="line">        quickSort(arr, left,curArr[<span class="number">0</span>] <span class="number">-1</span> );</span><br><span class="line">        quickSort(arr, curArr[<span class="number">1</span>]+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>]=&#123;<span class="number">99</span>,<span class="number">11</span>,<span class="number">72</span>,<span class="number">62</span>,<span class="number">53</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">21</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = len(arr);</span><br><span class="line">    quickSort(arr,length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="2-1、小和问题"><a href="#2-1、小和问题" class="headerlink" title="2.1、小和问题"></a>2.1、小和问题</h4><p>问题描述</p><blockquote><p>求小和问题：在随机元素，随机数组大小的数组中，找出左边比右边元素小的所有元素之和。<br>例如：数组[4,2,5,1,7,3,6] 第一个元素4比2大，不算小和，5比4和2都大，那就是4+2=6；1比4和2和5都小，不算小和；7比前面的都大，那就是上次小和6+4+2+5+1=18；然后3前面比2和1大，那就是18+2+1=21；最后6比4、2、5、1、3都大，结果就是21+4+2+5+1+3=36。那么最后的结果就是36。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> *help = <span class="keyword">new</span> <span class="keyword">int</span>(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;=mid &amp;&amp; pSecond &lt;=R) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在左右两个区有谁小谁移动的原则</span></span><br><span class="line"><span class="comment">        看小和问题和逆序对问题时，要抓住一边分析。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">      （小和问题，因为要统计左区小于右区的数的数量，</span></span><br><span class="line"><span class="comment">      既统计左区比右区小的数，因为在排序的时候，左区可能会移动，</span></span><br><span class="line"><span class="comment">      故左区在移动后，无法在下一步查看右区大于的数，</span></span><br><span class="line"><span class="comment">      所以要一次性把针对左区当前数大的数全部记录下来</span></span><br><span class="line"><span class="comment">        逆序对问题，则需要一个一个记录左区比右区大的数。）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sum += arr[pFirst] &lt; arr[pSecond] ? arr[pFirst]*(R-pSecond+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">        help[i++]  = arr[pFirst] &lt; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;= mid ) &#123;</span><br><span class="line">        help[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (R-L+<span class="number">1</span>); k++) &#123;</span><br><span class="line">        arr[L+k] = help[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L==R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>  mid = L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">//  相当于  int  mid = L+(R-L)/2;</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = smallSum(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightSum = smallSum(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">int</span> leftAndRightSum = allSum(arr,L,mid,R);</span><br><span class="line">    <span class="keyword">return</span>  leftSum + rightSum + leftAndRightSum;</span><br><span class="line"><span class="comment">//    return smallSum(arr, L, mid)+smallSum(arr, mid + 1, R)+allSum(arr,L,mid,R);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span> <span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">nullptr</span> || length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum(arr,<span class="number">0</span>,length <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-0、插入排序"><a href="#3-0、插入排序" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h3><p>算法描述:</p><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></blockquote><p>动画演示:<br><img alt="插入排序" src="https://img-blog.csdn.net/20180711042900649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>一般来说，插入排序都采用in-place在数组上实现。具体算法流程如下：<br>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；<br>重复步骤2~5。</p></blockquote><h4 id="3-0、插入排序-1"><a href="#3-0、插入排序-1" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h4><blockquote><p>(插入排序;时间A:N^2 , B:N^2 , E:N;空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、在对比的时候不交换；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;; length;i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span>&amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以直接交换。因为current记录了最后一个值，</span></span><br><span class="line"><span class="comment">            所以这里使用向后移动思想。</span></span><br><span class="line"><span class="comment">            exchangee(arr, preIndex, current);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex --;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法二、在对比的时候进行交换；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j&gt;;=<span class="number">0</span> &amp;amp;&amp;amp; arr[j]&gt;;arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><p>算法描述:</p><blockquote><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p></blockquote><p>动画演示:<br><img alt="希尔排序" src="https://img-blog.csdn.net/20180711042930449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法流程：<br>选择一个增量序列t1，t2，…，tk，其中ti&gt;;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></blockquote><h4 id="4-0、希尔排序"><a href="#4-0、希尔排序" class="headerlink" title="4.0、希尔排序"></a>4.0、希尔排序</h4><blockquote><p>(插入排序;时间A:N^1.3 , B:N^2 , E:N;空间1;不稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (又称缩小增量排序)</span></span><br><span class="line"><span class="comment">    通过实验，大量本表现出，平均时间复杂度为N^1.3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> gap = length;</span><br><span class="line">    <span class="keyword">while</span> (gap&gt;;<span class="number">1</span>)&#123;</span><br><span class="line">        gap = gap/<span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i&lt;;length; i+=gap) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span> &amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">                arr[i]  = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex+gap] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h3><p>算法描述:</p><blockquote><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><p>动画演示:<br><img alt="选择排序" src="https://img-blog.csdn.net/20180711042950325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现逻辑:</p><blockquote><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法流程如下：<br>初始状态：无序区为R[1..n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p></blockquote><h4 id="5-0、选择排序"><a href="#5-0、选择排序" class="headerlink" title="5.0、选择排序"></a>5.0、选择排序</h4><blockquote><p>(选择排序;时间A:N^2 , B:N^2 , E:N^2 ; 空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;length<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;   <span class="keyword">int</span> minIndex =i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;;length;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h3><p>算法描述:</p><blockquote><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>动画演示:<br><img alt="堆排序" src="https://img-blog.csdn.net/20180711043016142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p></blockquote><p>实现逻辑:</p><blockquote><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p></blockquote><h4 id="6-0、堆排序"><a href="#6-0、堆排序" class="headerlink" title="6.0、堆排序"></a>6.0、堆排序</h4><blockquote><p>(选择排序;时间A:NlogN,B:NlogN,E:NlogN;空间1;不稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">        堆的概念：对于大根堆，其子树下的所有节点，</span><br><span class="line">     包括它自己在内的最大值为头结点。</span><br><span class="line">        时间复杂度为0+log1+log2+……数学上可以证明</span><br><span class="line">     这个值收敛于O(N)</span><br><span class="line">*/</span><br><span class="line">//向上走</span><br><span class="line">void heapInsert(int arr[],int index)&#123;</span><br><span class="line">    while (arr[index] &gt;; arr[(index-1)/2]) &#123;</span><br><span class="line">        exchangee(arr,index, (index-1)/2);</span><br><span class="line">        index = (index -1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//向下走</span><br><span class="line">//size为最右的边界，size是取不到的.</span><br><span class="line">void heapify(int arr[],int index ,int size)&#123;</span><br><span class="line">    int leftChild = index*2 + 1;</span><br><span class="line">    while (leftChild &lt;; size) &#123;</span><br><span class="line">        int maxChild = leftChild + 1 &lt;; size &amp;amp;&amp;amp; arr[leftChild+1] &gt;;arr[leftChild] ? leftChild+1 : leftChild;</span><br><span class="line">        int maxAll = arr[maxChild] &gt;; arr[index] ? maxChild: index;</span><br><span class="line">        if (maxAll  == index) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, maxAll, index);</span><br><span class="line">        index = maxAll;</span><br><span class="line">        leftChild = index*2 +1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0;i &lt;;length;i++)&#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    int size = length;</span><br><span class="line">    exchangee(arr, 0, --size);</span><br><span class="line">    while (size &gt;; 0)&#123;</span><br><span class="line">        //heapify时间复杂度为O(logN)</span><br><span class="line">        heapify(arr, 0, size);</span><br><span class="line">        exchangee(arr, 0, --size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><p>算法描述:</p><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p>动画演示:<br><img alt="归并排序" src="https://img-blog.csdn.net/20180711043050105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p></blockquote><h4 id="7-0、二路归并排序"><a href="#7-0、二路归并排序" class="headerlink" title="7.0、二路归并排序"></a>7.0、二路归并排序</h4><blockquote><p>(插入排序;时间A:N<em>logN,B:N</em>logN,E:N*logN;空间N;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    归并排序内部缓存法 可以把空间复杂度降到O(1)；</span></span><br><span class="line"><span class="comment">    归并排序原地归并法 也可以把空间复杂度降到O(1)但是时间复</span></span><br><span class="line"><span class="comment">    杂度会变成O(N^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> M,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* cent = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M &amp;amp;&amp;amp; pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst] &lt;; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; (R-L+<span class="number">1</span>); j++) &#123;</span><br><span class="line">        arr[L+j] = cent[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, L, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || length&lt;;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(<span class="built_in">array</span>,<span class="number">0</span>,length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h3><p>算法描述:</p><blockquote><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p></blockquote><p>动画演示:<br><img alt="计数排序" src="https://img-blog.csdn.net/20180711043148643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>对所有的计数累加(从桶中的第0个元素开始，每一项和前一项相加);<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项,<br>每放一个元素就将C(i)减去1，是为了保证算法的稳定性。</p></blockquote><h4 id="8-0、计数排序"><a href="#8-0、计数排序" class="headerlink" title="8.0、计数排序"></a>8.0、计数排序</h4><blockquote><p>(计数排序;时间A:N+k,B:N+k,E:N+k;空间N+k;稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*    输入的元素是 n 个 0到 k 之间的整数</span><br><span class="line">      当k不是很大并且序列比较集中时，计数排序是一个很有效的</span><br><span class="line">   排序算法。</span><br><span class="line">      下面算法是输入的数组中的最小值大于等于0的情况，</span><br><span class="line">   可以根据需求更改。    </span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void countSort(int arr[] ,int length)&#123;</span><br><span class="line">    int max = arr[0];</span><br><span class="line">    int lastIndex=  0;</span><br><span class="line">    for (int i = 1; i&lt;;length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    int* sortArr  = new int[max+1]();</span><br><span class="line">    for (int j = 0; j&lt;; length; j++) &#123;</span><br><span class="line">        sortArr[arr[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int k = 0; k&lt;;max+1; k++) &#123;</span><br><span class="line">        while (sortArr[k]&gt;;0) &#123;</span><br><span class="line">            arr[lastIndex++] = k;</span><br><span class="line">            sortArr[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h3><p>算法描述:</p><blockquote><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p></blockquote><p>图片演示:<br><img alt="桶排序" src="https://img-blog.csdn.net/201807110432136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。</p></blockquote><h4 id="9-0、桶排序"><a href="#9-0、桶排序" class="headerlink" title="9.0、桶排序"></a>9.0、桶排序</h4><blockquote><p>桶排序(时间A:N+k,B:N^2,E:N+k;空间N+k;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序是: 桶思想排序 + 一个普通的排序（常用快速排序）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark bucketSort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//size  为一个桶的囊括的数的范围</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到最大最小值</span></span><br><span class="line">    <span class="keyword">long</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">long</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i] &lt;; min ? arr[i]: min;</span><br><span class="line">        max = arr[i] &gt;; max ? arr[i]: max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最小值等于最大值说明数组中就一种数</span></span><br><span class="line">    <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>)((max -min)/size +<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(bucketCount);</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把数组中的数 扔进桶里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;  i &lt;; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        bid = getGroupCount(arr[i], bucketCount, min, max);</span><br><span class="line">        bucket[bid].push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;; bucketCount; i++) &#123;</span><br><span class="line">        <span class="comment">//对桶内进行插入排序。按照升序，这样可以保证从下往上读的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (bucket[i][j] &lt;; bucket[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(bucket[i][j],bucket[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;; bucket[i].size(); t++) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;;&lt;;bucket[i][t]&lt;;&lt;;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    int *newArr = new int[len];</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;bucketCount ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            arr[index++] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="9-1、桶排序思想"><a href="#9-1、桶排序思想" class="headerlink" title="9.1、桶排序思想"></a>9.1、桶排序思想</h4><p>问题描述</p><blockquote><p>数组最大值问题。<br>给定一个无序数组，求如果排序之后，相邻两数的最大差值，<br>要求时间复杂度O（N），且要求不能用基于比较的排序。<br>以此题发现桶排序妙趣思想.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size<span class="number">-1</span>)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxGroup</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到系统的最大值和系统的最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i]&lt;;min ? arr[i]:min;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* maxValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>* minValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span>* flag = <span class="keyword">new</span> <span class="keyword">bool</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;;len; j++) &#123;</span><br><span class="line">        bid = getGroupCount(arr[j], len, min, max);</span><br><span class="line">        minValue[bid] = minValue[bid]? (minValue[bid]&lt;;arr[j]?minValue[bid]:arr[j]):arr[j];</span><br><span class="line">        maxValue[bid] = maxValue[bid]? (maxValue[bid]&gt;;arr[j]?maxValue[bid]:arr[j]):arr[j];</span><br><span class="line">        flag[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k= <span class="number">1</span> ; k&lt;;len+<span class="number">1</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[k]) &#123;</span><br><span class="line">            res = res &gt;; (minValue[k] - maxValue[lastMax]) ? res :(minValue[k] - maxValue[lastMax]);</span><br><span class="line">            lastMax =k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h3><p>算法描述:</p><blockquote><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p></blockquote><p>动画演示:<br><img alt="基数排序" src="https://img-blog.csdn.net/20180711043311284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>取得数组中的最大数，并取得位数；&lt;br /<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p></blockquote><h4 id="10-0、基数排序"><a href="#10-0、基数排序" class="headerlink" title="10.0、基数排序"></a>10.0、基数排序</h4><blockquote><p>(基数排序;时间A:N <em> k , B:N </em> k , E:N * k ; 空间N+k ; 稳定)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到传入数的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRadixCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count /<span class="number">10</span> &gt;;<span class="number">0</span>) &#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到10的传入位数的次方(10^num)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTenRadixCount</span><span class="params">(<span class="keyword">int</span> radixCount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tenRadix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (radixCount &gt;; <span class="number">0</span> ) &#123;</span><br><span class="line">        tenRadix *= <span class="number">10</span>;</span><br><span class="line">        radixCount --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tenRadix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;; length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> radixCount = getRadixCount(max);</span><br><span class="line">    <span class="keyword">int</span> tenRadixCount = getTenRadixCount(radixCount);</span><br><span class="line">    <span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>* num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();</span><br><span class="line">    <span class="keyword">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (multiplier &lt;; tenRadixCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curCount = arr[i]/multiplier%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> k = num[curCount];</span><br><span class="line">            bucket[curCount][k] = arr[i];</span><br><span class="line">            num[curCount]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">0</span>; k&lt;;num[j]; k++) &#123;</span><br><span class="line">                    arr[index++]  =  bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把桶清空，准备下一次循环。</span></span><br><span class="line">            num[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        multiplier *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法学习</title>
      <link href="/2019/04/11/python%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/11/python%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><ul><li>单双引号皆可,如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来,如果既包括<code>&#39;&#39;</code>又包括<code>&quot;&quot;</code>,那么就使用转义字符来标识</li><li>通过<code>input()</code>输入进来的所有东西默认是一个字符串</li><li><p><code>print()</code>在列表里输出遇到<code>&quot;,&quot;</code>时会输出一个空格</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'asd'</span>,<span class="string">"asd"</span>)</span><br><span class="line">asd asd</span><br></pre></td></tr></table></figure></li><li><p>可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></li><li><p>如果有很多换行，用<code>\n</code>写在一行里不好阅读，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line"><span class="comment"># 上面是在交互式命令行内输入。在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入</span></span><br></pre></td></tr></table></figure><blockquote><p>   <strong>注意!!!</strong> <code>...</code> 是提示符，不是代码的一部分：</p></blockquote></li></ul><h1 id="数据类型与变量"><a href="#数据类型与变量" class="headerlink" title="数据类型与变量"></a>数据类型与变量</h1><ul><li><p>Python是<strong>大小写敏感</strong>的</p></li><li><p><code>None</code>是python中一个特殊的值——<strong>空值</strong>，None不能理解为0，因为0是有意义的，而None是一个特殊的空值</p></li><li><p>可以把<strong>任意数据类型</strong>赋值给变量，<strong>同一个变量</strong>可以被赋值为<strong>不同类型的数据</strong></p></li></ul><blockquote><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。<br>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p></blockquote><ul><li><p>Python中，<code>/</code>除法计算结果是<strong>浮点数</strong>，即使是两个整数<strong>恰好整除，结果也是浮点数</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span>/<span class="number">3</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure></li><li><p>还有一种除法是<code>//</code>，称为<code>地板除</code>，两个整数的除法仍然是整数 <strong>(即使除不尽)</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span>//<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>Python的<strong>整数没有大小限制</strong></p></li><li>浮点数也没有大小限制，但是<strong>超出一定范围</strong>就直接表示为<code>inf</code></li></ul><h1 id="字符串与编码"><a href="#字符串与编码" class="headerlink" title="字符串与编码"></a>字符串与编码</h1><ul><li><p><code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>) <span class="comment"># 也可用十六进制</span></span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure></li><li><p>在知道字符整数编码的情况下，还可以用<strong>十六进制</strong>这么写字符</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span></span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p><code>bytes</code>的每个字符只占用一个字节</p></li><li>使用<code>encode()</code>将Unicode字符编码为<code>bytes</code>，使用<code>decode()</code>将其重新变为<code>str</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt中的setWindowFlags方法</title>
      <link href="/2019/03/10/Qt%E4%B8%AD%E7%9A%84setWindowFlags%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/10/Qt%E4%B8%AD%E7%9A%84setWindowFlags%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt中的setWindowFlags方法"><a href="#Qt中的setWindowFlags方法" class="headerlink" title="Qt中的setWindowFlags方法"></a>Qt中的setWindowFlags方法</h1><p>在Qt中，可使用setWindowFlags方法对窗口进行一些特殊属性的设置，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint);<span class="comment">//去掉窗口边框</span></span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);<span class="comment">//窗口置顶</span></span><br></pre></td></tr></table></figure></p><p>当多次使用该方法时，之后的修改会<strong>覆盖</strong>掉之前的结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint);</span><br><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);</span><br><span class="line"><span class="comment">//产生一个置顶的有边框的窗口（去边框的效果被覆盖掉）</span></span><br></pre></td></tr></table></figure></p><p>所以，如果想用setWindowFlags同时实现多种效果,应该这样写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint|Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></p><p>使用“|”可实现多种效果同时出现，有点类似金工实习里遇到的那个电梯模型的多状态设置。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Qt </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二寒假日常记录（持续更新中...）</title>
      <link href="/2019/01/19/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/19/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Status to be updated…<br><a id="more"></a></p><h1 id="理论-算法方面"><a href="#理论-算法方面" class="headerlink" title="理论/算法方面"></a>理论/算法方面</h1><p>学习中…</p><h1 id="项目方面"><a href="#项目方面" class="headerlink" title="项目方面"></a>项目方面</h1><p>积极筹备中…</p><h1 id="比赛方面"><a href="#比赛方面" class="headerlink" title="比赛方面"></a>比赛方面</h1><h2 id="节能减排大赛"><a href="#节能减排大赛" class="headerlink" title="节能减排大赛"></a>节能减排大赛</h2><p>造数据！</p><p><strong>造数据！！</strong></p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>先划水半个月…</p><h1 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h1><p>Nothing</p><h1 id="每日记录"><a href="#每日记录" class="headerlink" title="每日记录"></a>每日记录</h1><table><thead><tr><th style="text-align:center">日 期</th><th style="text-align:center">理 论 / 算 法</th><th style="text-align:center">项 目 / coding / 实 践</th><th style="text-align:center">杂 活 儿</th><th style="text-align:center">生 活 / 备 注</th></tr></thead><tbody><tr><td style="text-align:center">1.19</td><td style="text-align:center">Markdown语法学习</td><td style="text-align:center">Blog新域名+国内DNS+https</td><td style="text-align:center">整理美术素材</td><td style="text-align:center">假期开始          </td></tr><tr><td style="text-align:center">1.20</td><td style="text-align:center">了解MVC框架相关知识</td><td style="text-align:center">帮学弟改代码(快速排序优化)<br>网站搭建后续工作</td><td style="text-align:center">更新博文</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.21</td><td style="text-align:center">Hexo框架学习</td><td style="text-align:center">改网站的bug…<br>博客换用新框架</td><td style="text-align:center">整理美术素材</td><td style="text-align:center">被空格不断制裁Orz…</td></tr><tr><td style="text-align:center">1.22</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">请灵，守夜<br>心情不好没干事</td></tr><tr><td style="text-align:center">1.23</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">爷爷去世一周年忌日<br>心情不好继续休息</td></tr><tr><td style="text-align:center">1.24</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.25</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">聚会</td></tr><tr><td style="text-align:center">1.26</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">身体不适，效率低下</td></tr><tr><td style="text-align:center">1.27</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">开始构思UI方案</td><td style="text-align:center">-</td><td style="text-align:center">仍然效率低下</td></tr><tr><td style="text-align:center">1.28</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">整理各种文件和资源</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.29</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">进行开发准备工作</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.30</td><td style="text-align:center">-</td><td style="text-align:center">工具/API准备工作</td><td style="text-align:center">收到ZF老师短信，安排进组前的假期学习任务</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.31</td><td style="text-align:center">-</td><td style="text-align:center">消息推送模块开发</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.1</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">算法题目*3</td><td style="text-align:center">-</td><td style="text-align:center">理发</td></tr><tr><td style="text-align:center">2.2</td><td style="text-align:center">动态规划</td><td style="text-align:center">补注释</td><td style="text-align:center">收集算法学习资源</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.3</td><td style="text-align:center">各类排序优化<br>哈希算法</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.4</td><td style="text-align:center">搜索剪枝优化</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.5</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">过年</td></tr><tr><td style="text-align:center">2.6</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">过年</td></tr><tr><td style="text-align:center">2.7~<br>2.14</td><td style="text-align:center">-</td><td style="text-align:center">项目开发前期工作</td><td style="text-align:center">-</td><td style="text-align:center">去乡下</td></tr><tr><td style="text-align:center">2.15</td><td style="text-align:center">并查集</td><td style="text-align:center">-</td><td style="text-align:center">整理素材，写文档</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.16</td><td style="text-align:center">SQL知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法学习</title>
      <link href="/2019/01/19/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/19/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇Markdown文档"><a href="#这是一篇Markdown文档" class="headerlink" title="这是一篇Markdown文档"></a>这是一篇Markdown文档</h1><h2 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h2><p>我是一段正文，会有<strong>关键字</strong>，另外<del>不关键的句子我会删掉</del></p><hr><p>这是第二段正文，在这里会有一个<em>斜体关键字</em>，还会有一个<code>内嵌代码块</code>，完美！下一行会有一个引用</p><blockquote><p>我是一行引用。——鲁迅</p><p>我也是。——周树人</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>接下来试验列表，先是无序的</p><ul><li>无序列表</li><li>我也是</li><li>me too</li></ul><hr><p>下边是有序的</p><ol><li>比如我</li><li>and me</li><li>ho!</li></ol><h3 id="突然发现还可以嵌套"><a href="#突然发现还可以嵌套" class="headerlink" title="突然发现还可以嵌套"></a>突然发现还可以嵌套</h3><blockquote><ul><li>外层<ul><li>内层</li><li>我也是内层<ul><li>内层的内层</li></ul></li></ul></li><li>第二个外层</li></ul></blockquote><h3 id="果然有序的也可以"><a href="#果然有序的也可以" class="headerlink" title="果然有序的也可以"></a>果然有序的也可以</h3><blockquote><ol><li>外层<ol start="2"><li>内层</li><li>我也是内层<ol start="4"><li>内层的内层</li></ol></li></ol></li><li>第二个外层</li></ol></blockquote><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下边我会写一些代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来试验超链接，这是我的<a href="https://ranchoturing.com" target="_blank" rel="noopener">个人博客链接</a><br>这是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a>,这也是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a>,这还是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a></p><p>在这儿可以插一张图片<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="图片"></p><p>这样插图片也行<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="一张图片">,再次<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="一张图片"></p><p>链接也可以用索引的方式存在后边，算是行内式和参考式超链接的一种混合运用，如：<a href="https://ranchoturing.com" target="_blank" rel="noopener">建国的小屋</a></p><p>另外，还有自动链接，来处理网址和邮箱地址之类的，如<a href="mailto:&#51;&#x31;&#51;&#53;&#x36;&#49;&#51;&#52;&#52;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#51;&#x31;&#51;&#53;&#x36;&#49;&#51;&#52;&#52;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这个真的是最麻烦的了，所以用最简单的格式写就好，注意对齐</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">一斤多少钱呀</th><th style="text-align:right">到底要买多少呢</th></tr></thead><tbody><tr><td style="text-align:center">超大超好吃的苹果</td><td style="text-align:center">5.0</td><td style="text-align:right">33</td></tr><tr><td style="text-align:center">绿色的香蕉</td><td style="text-align:center">8.8</td><td style="text-align:right">25</td></tr><tr><td style="text-align:center">梨子</td><td style="text-align:center">6.5</td><td style="text-align:right">10</td></tr></tbody></table><h2 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h2><ul><li style="list-style: none"><input type="checkbox" checked> get</li><li style="list-style: none"><input type="checkbox"> can’t</li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站感言</title>
      <link href="/2019/01/04/build-site/"/>
      <url>/2019/01/04/build-site/</url>
      
        <content type="html"><![CDATA[<ul><li style="list-style: none"><input type="checkbox" checked> 个人网站</li><li style="list-style: none"><input type="checkbox" checked> 一年份的域名 </li></ul><p>按照惯例干了好事/ 坏事要写小作文来记录，<del>趁热打铁先写在空间，等白天电脑有电了再更新到网站上</del></p><p>经过一晚上的折腾，终于差不多搞定了网站，并且赶在没电关机的前几秒截了图。<br><a id="more"></a></p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>一直以来，被好多学长和前辈提醒过要写博客记录学习进度才能有收获。</p><p>但由于各（fei）种（chang）原（de）因（lan），在其他同学不断写博客更新刷题笔记、分享技术的时候，我还一直停留在用本地的文本文档记随笔的阶段。github上没有一行代码、csdn的博客里只写了一篇开头，<del>还开坑不填</del>。</p><p>仔细想想，近一年来还是学到/接触了不少值得记录下来的东西的。如果好好写写博客梳理一下，肯定会有很多新的收获。</p><p>所以，大概一两个月前就开始准备好好整理一下电脑上的随笔，更到博客里。结果没过几天，就被csdn坑了一把，见识到了<strong>辣鸡</strong>csdn捞钱时的丑恶嘴脸，从此粉转黑。（当然，更博的计划也就被我以这个理由暂时搁置了。嗯，这个理由很正当，没毛病，<strong>绝对不是我想偷懒</strong></p><p>之后又试了下欧阳之前推荐过的cnblog，功能虽然很强大，但还停留在零几年的老旧的界面风格实在是让人感觉很难受，所以就放弃了cnblog，开始打起了自己写个个人网站的主意。</p><h2 id="着手准备"><a href="#着手准备" class="headerlink" title="着手准备"></a>着手准备</h2><p>一开始是打算自己从头开始写的，但是具有知难而退的良好品质的我果断就放弃了这个想法，开始寻找一些开源的框架和方案。不得不说，站在巨人的肩膀上确实是一件幸福的事，在计算机领域，由于大家对“开源精神”的推崇，这种幸福更是被无限地放大了，很多问题都能找到前辈们留下的解决方案，新问题也能得到大佬们热心的解答。</p><p>当时的想法是把网站托管在github上，也省去了自己购买和配置服务器与域名的麻烦和开销。多方考虑之下，放弃了写动态网页的打算而选择了静态网页，之后又选择放弃hexo，选择了Jekyll来开发。所以最近的一段时间基本没有写题训练，偷懒之余，一直在学习git和这些方面的东西。</p><p>不过在十几天前参加完<strong>腾讯云开发者大会</strong>回来之后，结合之后的各种计划，又改变了主意，准备把网站项目托管在coding上。</p><p>在这之前，考虑到github服务器在国外，有许多不确定因素，所以早就有过换用coding或者码云的想法，不过这两家都不是大公司，所以还是不太信任他们。</p><p>这次大会上有公布腾讯和coding的合作计划，coding升级成“腾讯云开发者平台”，有了腾讯爸爸背书，那么选择coding自然也就成了顺理成章的事儿了。</p><p>之后就是忙活各种杂活儿了，顺带还是没有抵挡住诱惑，搞了个.cf顶级域名。</p><h2 id="正式完工"><a href="#正式完工" class="headerlink" title="正式完工"></a>正式完工</h2><p>然后因为考试和其他事情就又搁置下了，结果今晚收到域名供应商的邮件，他们访问了我的域名发现还没有被启用，接下来几天他们会每天都来访问，如果还是没有启用，那么为了避免域名资源被浪费，他们会收回域名。。。。</p><p>于是就大晚上开始开工干活，建项目，从github克隆项目到本地的git仓库，再push到coding上新的远程仓库，然后部署，绑定自己的域名和dns服务器等等。</p><p>出来的效果基本上还是不错的，接下来就是完善内容和修改一些细节啦。</p><p>顺带，现在的dns服务器在国外，面对国内严重污染的dns环境可能有些无力，为了避免被运营商劫持或者其他dns污染的情况，还得找个时间换成国内的dns服务器。</p><p>另外，虽然.cf的顶级域名不错，但还是想要个.com的顶级域名，不过这个倒不是多重要，等以后把网站转到自己服务器上了再买吧。</p><p>以上。</p><hr><h2 id="2019-1-19更新："><a href="#2019-1-19更新：" class="headerlink" title="2019-1-19更新："></a>2019-1-19更新：</h2><p>已购买2年的<strong>.com</strong>顶级域名，并启用了<strong>https证书</strong>，换到了国内的DNS服务器。</p><p>现通过<a href="https://ranchoturing.com" target="_blank" rel="noopener">https://ranchoturing.com</a>及<a href="https://www.ranchoturing.com" target="_blank" rel="noopener">https://www.ranchoturing.com</a>均可访问博客网站，并且保留了原来的<a href="http://www.ranchoturing.cf" target="_blank" rel="noopener">http://www.ranchoturing.cf</a>。</p><hr><h2 id="2019-3-16更新："><a href="#2019-3-16更新：" class="headerlink" title="2019-3-16更新："></a>2019-3-16更新：</h2><p>因为发现coding的pages服务老是挂掉，所以昨晚连夜把博客从coding上迁移到了github上，本来很简单的事情，结果因为zz校园网硬是搞了好久。。。</p><p>移植到github之后，博客莫名其妙被校园网墙掉了，一直404，只能挂vpn或者手机开流量访问。。。</p><p>只能找时间去网络中心找人问下了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 网站建设 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
