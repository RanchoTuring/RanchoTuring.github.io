<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成与结构知识点速查表</title>
      <link href="/2019/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h1><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>随机存储器（RANDOM ACCESS MEMORY,RAM）</li><li>非易失性存储器（停电仍能保持内容）<ul><li>只读存储器ROM</li><li>可编程的只读存储器PROM:一次性写入</li><li>可擦可编程EPROM</li><li>可电擦可编程E2PROM</li><li>快擦除读写存储器FLASH MEMORY</li></ul></li></ol><h3 id="主要技术指标"><a href="#主要技术指标" class="headerlink" title="主要技术指标"></a>主要技术指标</h3><p>主存容量、存储器存取时间、存储周期</p><blockquote><p>通常存储周期<strong>略大于</strong>存取时间</p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>CPU使用<code>AR（地址寄存器)</code>  和  <code>DR（数码寄存器)</code>   和主存通过总线进行数据传送</p></li><li><p>CPU与主存之间采用<strong>异步工作方式</strong>，以<code>ready</code>信号表示一次<strong>访存操作的结束</strong></p><h3 id="SRAM与DRAM"><a href="#SRAM与DRAM" class="headerlink" title="SRAM与DRAM"></a>SRAM与DRAM</h3></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">静态存储器</th><th style="text-align:center">动态存储器</th></tr></thead><tbody><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">功耗</td><td style="text-align:center">较大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">不断电，信息就不会丢失</td><td style="text-align:center">需不断给MOS电容充电来保持信息<br>主要用于<strong>大容量存储器</strong></td></tr><tr><td style="text-align:center">速度</td><td style="text-align:center">快</td><td style="text-align:center">较慢（需要再生，浪费了时间</td></tr></tbody></table><h3 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h3><ul><li>位扩展：用多个存储器芯片对<strong>字长进行扩充</strong></li><li>字扩展：增加存储器中<strong>字的数量</strong></li><li>字位扩展：同时扩充</li></ul><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><ul><li>刷新周期（再生周期）一般为2ms</li><li></li></ul><hr><h1 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h1><p>必要性：控制并实现主机与外部设备之间的数据传送</p><h3 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h3><ol><li>专设I/O指令</li><li>利用访存指令完成I/O功能</li></ol><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ol><li>主机与外部设备之间的数据传送</li><li>数据缓冲，使主机与外部设备之间的速度匹配</li><li>接受主机命令，提供设备接口状态，按主机命令控制设备</li></ol><hr><h1 id="IO设备数据传送控制方式"><a href="#IO设备数据传送控制方式" class="headerlink" title="IO设备数据传送控制方式"></a>IO设备数据传送控制方式</h1><ol><li><p>程序直接控制方式</p></li><li><p>程序中断传送方式</p></li><li><p>直接存储器存取方式</p></li><li><p>I/O通道控制方式</p></li><li><p>外围处理机方式</p></li></ol><hr><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>由I/O设备或其他非预期的急需处理的事件所引起，<strong>使CPU暂时中断现在正在处理的程序，转至另一服务程序去处理这些事件，处理完后再返回原程序</strong>。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>CPU与I/O设备并行工作</li><li>硬件故障处理、实现人机联系</li><li>实现多道程序和分时操作</li><li>实现实时处理</li><li>实现应用程序与操作系统的联系（软中断）</li><li>多处理机系统各处理机之间的联系</li></ol><h3 id="相关术语及概念"><a href="#相关术语及概念" class="headerlink" title="相关术语及概念"></a>相关术语及概念</h3><ol><li>中断源的<strong>种类</strong>：内/外/软</li><li><p><strong>中断触发器</strong>（每个中断源都有一个，中断发生时先将其置1）—-&gt;<strong>中断寄存器</strong>（全机的中断触发器构成），其内容称为<strong>中断字</strong>或<strong>中断码</strong>—–&gt;CPU<strong>根据中断字确定中断源</strong>，转入相应的程序进行执行</p></li><li><p>按类别分为不同的<strong>中断级</strong>，同一级中再确定各个中断源的<strong>优先权</strong></p><blockquote><p>为保证数据的有效性，通常<strong>数据有效期短</strong>的设备优先权高，<strong>数据有效期长</strong>或具有<strong>数据自动恢复能力</strong>的设备优先权低。</p></blockquote></li><li><p>禁止中断：CPU内有“中断允许”触发器，其为1时，才可响应中断，称为“允许中断”，否则为</p><blockquote><p>进入<strong>中断服务程序后</strong>，自动“关中断”</p></blockquote></li><li><p>中断屏蔽：<strong>通过程序</strong>有选择的封锁部分中断，而允许其余部分中断得到响应</p><blockquote><pre><code>通过为**每个中断源**设置一个**中断屏蔽触发器**来屏蔽该设备的中断请求</code></pre></blockquote></li></ol><blockquote><p>有些中断是<strong>不可屏蔽的</strong>，这些中断享有最高优先权。</p></blockquote><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><ol><li>关中断   </li><li>保存断点和现场    </li><li>判别中断源，转向中断服务程序   </li><li>开中断   </li><li>执行中断服务程序</li><li>退出中断（关中断，恢复现场和断点，开中断，返回断点）</li></ol><h3 id="判别中断源"><a href="#判别中断源" class="headerlink" title="判别中断源"></a>判别中断源</h3><ol><li>查询法</li><li>串行排队链法</li></ol><hr><h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p>I/O设备与<strong>主存储器</strong>之间由硬件组成的直接数据通路，用于<strong>成组数据</strong>的传送 </p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ol><li>CPU暂停方式</li><li>CPU周期窃取方式</li><li>直接访问存储器工作方式</li></ol><hr><h1 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h1><p>I/O通道是计算机系统中代替CPU管理控制外部设备的<strong>独立部件</strong>，是一种能执行有限条I/O指令集合的I/O处理机</p><ol><li>字节多路通道</li><li>数组多路通道</li><li>选择通道</li></ol><hr><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p>各模块之间传送信息的通路，是由<strong>2个或以上</strong>源部件传送信息到<strong>一个或多个</strong>部件的的一组传输线</p><blockquote><p>若<strong>仅用于1对1或1对多</strong>的连接，则不称为总线</p></blockquote><h3 id="总线组成"><a href="#总线组成" class="headerlink" title="总线组成"></a>总线组成</h3>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 知识点速查表 </tag>
            
            <tag> CUMTB复习资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言知识点速查表</title>
      <link href="/2019/05/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/05/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="8086的参数"><a href="#8086的参数" class="headerlink" title="8086的参数"></a>8086的参数</h2><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">num</th></tr></thead><tbody><tr><td style="text-align:center">地址总线</td><td style="text-align:center">20条/位（1Mb）</td></tr><tr><td style="text-align:center">控制总线</td><td style="text-align:center">16条/位(字长是16)</td></tr><tr><td style="text-align:center">数据总线</td><td style="text-align:center">16条/位</td></tr><tr><td style="text-align:center">指令队列</td><td style="text-align:center">6字节</td></tr></tbody></table><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:left"></th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">数据寄存器  *  4 <br>（都可拆分为8位:AH AL）</td><td style="text-align:left">(accumulator)<strong>累加器</strong>   AX             (base)<strong>基址</strong>寄存器   BX  <br>(count)<strong>计数</strong>寄存器   CX                 (data)<strong>数据</strong>寄存器   DX</td><td>通用寄存器组</td></tr><tr><td style="text-align:center">指针和变址寄存器   *   4<br>(16位)</td><td style="text-align:left">(stack pointer)<strong>堆栈</strong>指针   SP        (base)<strong>基址</strong>指针 BP<br>(source index)<strong>源</strong>变址    SI         (destination)<strong>目的</strong>变址   DI</td><td>通用寄存器组</td></tr><tr><td style="text-align:center">控制寄存器</td><td style="text-align:left">16位标志寄存器    FLAG</td><td></td></tr><tr><td style="text-align:center">控制寄存器</td><td style="text-align:left">16位<strong>指令指针</strong>寄存器(instruction pointer)   IP</td><td>专用寄存器组</td></tr><tr><td style="text-align:center">段地址寄存器   *   4</td><td style="text-align:left">CS、DS、ES、SS      （都为16位）</td><td>专用寄存器组</td></tr></tbody></table><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><table><thead><tr><th>15</th><th></th><th></th><th></th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th></th><th>4</th><th></th><th>2</th><th></th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><table><thead><tr><th>共9个</th><th>1</th><th>0</th></tr></thead><tbody><tr><td><strong>CF</strong>     进位标志（carry）</td><td>运算时在<strong>最高位</strong>(符号位也算)有借位/进位</td><td>无借位/进位</td></tr><tr><td><strong>PF</strong>     奇偶（parity）</td><td>操作结果中1有<strong>偶数</strong>个（低8位）</td><td><strong>奇数</strong>个</td></tr><tr><td><strong>AF</strong>    辅助进位（auxiliary carry）</td><td><strong>字节运算</strong>时，<strong>低半字节</strong>向<strong>高半字节</strong>进位或借位</td><td>无进位/借位</td></tr><tr><td><strong>ZF</strong>     零标志</td><td>操作结果为<code>0</code></td><td>不为0</td></tr><tr><td><strong>SF</strong>     符号（sign）</td><td>运算结果为负（<strong>无符号数运算时SF会变，但无意义</strong>）</td><td>正</td></tr><tr><td><strong>TF</strong>     单步/跟踪（trace）</td><td>单步执行（在调试时可直接控制CPU状态）</td><td>连续执行</td></tr><tr><td><strong>IF</strong>      中断允许（interrupt enable）</td><td>允许CPU响应外部可屏蔽中断请求（每执行一条指令之后，自动产生一次内部中断）</td><td>不允许</td></tr><tr><td><strong>DF</strong>     方向 （direction）</td><td>字符串操作时从<strong>高地址</strong>向<strong>低地址</strong>方向进行</td><td>低-&gt;高</td></tr><tr><td><strong>OF </strong>   溢出 （overflow）</td><td><strong>有符号数</strong>运算时，结果超过了寄存器容纳范围</td></tr></tbody></table><h2 id="内存地址的计算"><a href="#内存地址的计算" class="headerlink" title="内存地址的计算"></a>内存地址的计算</h2><p><code>起始地址</code> = <code>段地址</code> * <code>10H</code></p><p><code>物理地址</code> = <code>起始地址</code> + <code>偏移地址</code></p><h2 id="MOV-的使用"><a href="#MOV-的使用" class="headerlink" title="MOV 的使用"></a>MOV 的使用</h2><ul><li><p><code>mov  寄存器 ，(立即数/寄存器/内存单元/段寄存器）</code></p></li><li><p><code>mov  内存单元，寄存器/立即数</code></p></li><li><p><code>mov  段寄存器，寄存器</code></p></li></ul><blockquote><p>不允许 mov    内存单元，内存单元</p></blockquote><h2 id="XCHG-的使用"><a href="#XCHG-的使用" class="headerlink" title="XCHG 的使用"></a>XCHG 的使用</h2><ul><li><p>必须有一个操作数在通用寄存器中</p></li><li><p>不能在内存单元之间直接交换数据；不能与段寄存器交换数据</p></li><li><p>数据类型必须一致</p></li></ul><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><ul><li><p>LEA 16位寄存器，（存储器操作数/偏移地址）  将存储器操作数的地址偏移量传送到目的操作数</p><blockquote><p>设（BX）=1000H,(DI)=0100H </p><p>LEA BX,[BX+DI+0010H]         执行后，EA=1110H</p><p>故（bx）=1110H</p></blockquote></li><li><p>LDS  (SI/BX)，内存变量      将内存变量指向的连续4个字节内容送到<strong>DS和目的操作数</strong>中</p></li><li><p>LES  DI,内存变量      <strong>ES和目的操作数</strong></p></li></ul><h2 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h2><ul><li><p>LAHF    flag的低八位内容-&gt;ah</p></li><li><p>SAHF  ah-&gt;flag的低八位内容</p></li><li><p>PUSHF   POPF   标志进出栈</p></li></ul><h2 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h2><ul><li>IN  （al/ax），(立即数/DX)    从指定端口地址中读入一个byte/word/dword，并传送到al/ax中</li><li>out  (立即数/dx)，(al/ax)      将al/ax中的数据输出到指定端口中</li></ul><h2 id="ADD-的使用"><a href="#ADD-的使用" class="headerlink" title="ADD 的使用"></a>ADD 的使用</h2><ul><li><code>add   寄存器，（数据/寄存器/内存单元）</code></li><li><code>add   内存单元，寄存器</code></li></ul><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><ul><li><p><code>SS:SP</code> 始终指向栈顶</p><blockquote><p><strong>栈空时</strong>，SS:SP指向栈空间最后地址单元的下一单元</p><blockquote><p> e.g.  将10000H~1000FH这段空间当作栈，</p><p><code>SS = 1000H</code>   <code>SP = 10H</code></p></blockquote></blockquote></li><li><p>POP和PUSH操作<code>2 byte</code>的数据</p></li><li><p>由高字节向低字节压栈（随着数据增多，SP逐渐减小）</p><blockquote><p>新数据入栈之后，SP = SP - 2</p></blockquote></li></ul><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><table><thead><tr><th></th><th>操作数</th><th></th></tr></thead><tbody><tr><td>立即寻址</td><td>立即数</td><td>mov ax,1234h</td></tr><tr><td>寄存器寻址</td><td>寄存器</td><td>mov ax,bx</td></tr></tbody></table><h3 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h3><blockquote><p>有效地址EA=基址（bx/bp）+变址(si/di)+位移量(8/16位带符号数)<br>(用BP则默认操作数在SS,否则在<strong>DS</strong>)</p></blockquote><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>直接寻址</td><td>偏移地址</td><td>mov ax ,[1234H]</td></tr><tr><td>寄存器间接寻址</td><td>操作数在存储器中，但其偏移量在寄存器里</td><td>mov ax,[bx]</td></tr><tr><td>寄存器相对寻址</td><td></td><td>mov  ax,[bx+1000h]</td></tr><tr><td>基址变址寻址</td><td></td><td>mov ax,[bx+si]</td></tr><tr><td>相对基址变址寻址</td><td></td><td>mov ax,[bx+si+2000h]</td></tr></tbody></table><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><ul><li><code>ADD/ADC   通用寄存器，（通用寄存器/内存操作数/立即数）</code></li><li>ADD/ADC    内存操作数，（通用寄存器/立即数）</li></ul><blockquote><p>ADC 的结果需要在<code>目的操作数+源操作数</code>的基础上再加上<code>执行前的CF</code></p></blockquote><ul><li>inc 加一指令（CF不受影响） 可以为任何8/16/32位<strong>通用寄存器</strong>或<strong>存储器操作数</strong></li></ul><h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><ul><li>sub/sbb 通用寄存器，通用寄存器/内存操作数/立即数</li><li>sub/sbb 内存操作数，（通用寄存器/立即数）</li></ul><blockquote><p> sbb 的结果需要在<code>目的操作数-源操作数</code>的基础上再减去<code>执行前的CF</code></p></blockquote><ul><li>cmp 目的操作数-源操作数（<strong>不保留结果，只保留对标志寄存器的影响</strong>）</li><li><p>dec 减一指令（cf不受影响）可以为任何8/16/32位<strong>通用寄存器</strong>或<strong>存储器操作数</strong></p></li><li><p>Neg 取补</p></li></ul><h3 id="乘法（只影响C、O，其余四种未定义）"><a href="#乘法（只影响C、O，其余四种未定义）" class="headerlink" title="乘法（只影响C、O，其余四种未定义）"></a>乘法（只影响C、O，其余四种未定义）</h3><ul><li><p>无符号 MUL </p><blockquote><ul><li>字节相乘  ax&lt;– al * 8位操作数</li><li>字相乘  (dx,ax)&lt;– ax * 16位操作数</li></ul></blockquote></li><li><p>带符号 IMUL</p></li></ul><h3 id="除法（6种标志位都没有定义）"><a href="#除法（6种标志位都没有定义）" class="headerlink" title="除法（6种标志位都没有定义）"></a>除法（6种标志位都没有定义）</h3><ul><li><p>div </p><blockquote><ul><li>字÷字节  ax÷8位操作数=al余ah</li><li>双字÷字  (dx,ax)÷ 16位操作数=ax余dx</li></ul></blockquote></li><li><p>带符号 idiv</p></li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><ol><li><p><strong>CBW</strong> (convert byte to word)</p><p> AL中的有符号数扩展到AX</p><ul><li>AL最高位为1，AH&lt;–0FFH</li><li>AL最高位为0，AH&lt;–00H</li></ul></li><li><p><strong>CWD</strong>(word to double word)</p><p> AX  (dx,ax)</p><ul><li><p>ax   1   dx&lt;–0ffffH</p></li><li><p>ax   0  dx&lt;–0000H</p></li></ul></li></ol><h3 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">对标志寄存器的影响</th></tr></thead><tbody><tr><td style="text-align:center">and、test、or、xor</td><td style="text-align:center">of=0   cf=0  其余四种没有定义</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">无影响</td></tr></tbody></table><blockquote><p>test 也是目的与，但不保留结果，只保留对寄存器的影响</p></blockquote><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul><li><p>助记符   （通用寄存器/存储器操作数），（立即数n/寄存器CL）      ;移位次数为n或CL</p><blockquote><p>8086中，<strong>n只能为1</strong>，移位次数大于1时一定要用CL</p></blockquote></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>逻辑左移    SHL</td><td>最高位-&gt;CF      0-&gt;最低位    其余左移</td></tr><tr><td>逻辑右移    SHR</td><td>0-&gt;最高位      最低位-&gt;CF    其余右移</td></tr><tr><td>算术左移    SAL</td><td>最高位-&gt;CF      0-&gt;最低位    其余左移</td></tr><tr><td>算术右移   SAR</td><td>新最高位=原最高位      最低位-&gt;CF    其余右移</td></tr></tbody></table><ul><li><p>移动次数大于0时，影响CSZP（A未定义），大于1时OF不受影响</p></li><li><p>次数=1时，O=C xor M   ;M为移位后操作数的最高位</p></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>循环左移    ROL</td><td>最高位-&gt;CF和最低位    其余左移</td></tr><tr><td>循环右移    ROR</td><td>最低位-&gt;CF和最高位    其余右移</td></tr><tr><td>带进位循环左移    RCL</td><td>最高位-&gt;CF      CF-&gt;最低位    其余左移</td></tr><tr><td>带进位循环右移   RCR</td><td>最低位-&gt;CF     CF-&gt;新最高位   其余右移</td></tr></tbody></table><ul><li>移动次数大于0时，影响C（SZPA未定义），大于1时OF不受影响</li><li>次数=1时，O=C xor M   ;M为移位后操作数的最高位</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>MoVS   lods   stos   cmps    (都可用B、w、d后缀)</p><blockquote><p>从ds:si 移动到es:di</p></blockquote><ul><li>cmps   repe/repz   找不相等的</li><li>scas   repne/repnz   找相等的</li><li>ins   目标串，dx      用来修改<h2 id="控制转移类指令"><a href="#控制转移类指令" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h2><h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3></li><li>jmp 16位（段内）/32位（段间）的除立即数之外的任何有效方式</li></ul><h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><ul><li>根据flag或CX的状态，决定是否转移</li><li>对于8086，只能是短程转移   -128~127</li><li>对于无符号数</li></ul><table><thead><tr><th>Above</th><th>below</th><th>equal</th><th>not</th></tr></thead><tbody><tr><td>大</td><td>小</td><td>等</td><td>非</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">cf</td><td style="text-align:center">&lt;</td><td style="text-align:center">&gt;=</td></tr><tr><td style="text-align:center">zf</td><td style="text-align:center">=</td><td style="text-align:center">!=</td></tr></tbody></table><ul><li><p>有符号数</p><p>  | greater | less | equal | not  |<br>  | ——- | —- | —– | —- |<br>  |         |      |       |      |</p></li></ul><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><ul><li><p>LOOP 标号</p><blockquote><p>每循环一次，CX的值减一；当CX=0时，停止循环</p></blockquote></li><li><p>LOOPZ/LOOPE   标号</p><blockquote><p>当CX!=0且zf=1时循环</p></blockquote></li><li><p>LOOPNZ/LOOPNE 标号</p><blockquote><p>当CX！=0且zf=0时循环</p></blockquote></li></ul><h3 id="调用返回指令"><a href="#调用返回指令" class="headerlink" title="调用返回指令"></a>调用返回指令</h3><ul><li>段内     call (近程过程标号/16位通用寄存器/16位存储器操作数)</li><li>段间      call(远程过程标号/32位存储器操作数)</li><li>REt   返回过程</li><li>int  中断</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 知识点速查表 </tag>
            
            <tag> CUMTB复习资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识入门</title>
      <link href="/2019/05/05/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2019/05/05/MySQL%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="21分钟MySQL基础入门"><a href="#21分钟MySQL基础入门" class="headerlink" title="21分钟MySQL基础入门"></a>21分钟MySQL基础入门</h1><p>为什么只需要21分钟呢？因为在我们大天朝有句话叫做三七二十一，你可以不管三七二十一开始使用 <code>MySQL</code> 及快速的方式入门 <code>MySQL</code>。其实21分钟把下面语句执行一遍是没有问题的，要理解的话估计不止21分钟，对于初学者来说只需满足自己需求可以增删改查等简易的维护即可。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>我下面所有的SQL语句是基于MySQL 5.6+运行。</p><p>MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格：</p><p><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/img/data.jpg" target="_blank" rel="noopener"><img src="https://github.com/jaywcjlove/mysql-tutorial/raw/master/img/data.jpg" alt="21分钟MySQL基础入门"></a></p><ul><li><code>表头(header)</code>: 每一列的名称;</li><li><code>列(col)</code>: 具有相同数据类型的数据的集合;</li><li><code>行(row)</code>: 每一行用来描述某个人/物的具体信息;</li><li><code>值(value)</code>: 行的具体信息, 每个值必须与该列的数据类型相同;</li><li><code>键(key)</code>: 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。</li></ul><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u 用户名 -p</span><br><span class="line">mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p</span><br><span class="line">mysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果</span><br><span class="line">mysql&gt; status;  # 显示当前mysql的version的各种信息</span><br><span class="line">mysql&gt; select version(); # 显示当前mysql的version信息</span><br><span class="line">mysql&gt; show global variables like &apos;port&apos;; # 查看MySQL端口号</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>对于表的操作需要先进入库<code>use 库名;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbk</span><br><span class="line">create database samp_db character set gbk;</span><br><span class="line">drop database samp_db; -- 删除 库名为samp_db的库</span><br><span class="line">show databases;        -- 显示数据库列表。</span><br><span class="line">use samp_db;     -- 选择创建的数据库samp_db</span><br><span class="line">show tables;     -- 显示samp_db下面所有的表名字</span><br><span class="line">describe 表名;    -- 显示数据表的结构</span><br><span class="line">delete from 表名; -- 清空表中记录</span><br></pre></td></tr></table></figure><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><blockquote><p>使用 create table 语句可完成对表的创建, create table 的常见形式: 语法：create table 表名称(列声明);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 如果数据库中存在user_accounts表，就把它从数据库中drop掉</span><br><span class="line">DROP TABLE IF EXISTS `user_accounts`;</span><br><span class="line">CREATE TABLE `user_accounts` (</span><br><span class="line">  `id`             int(100) unsigned NOT NULL AUTO_INCREMENT primary key,</span><br><span class="line">  `password`       varchar(32)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;用户密码&apos;,</span><br><span class="line">  `reset_password` tinyint(32)       NOT NULL DEFAULT 0 COMMENT &apos;用户类型：0－不需要重置密码；1-需要重置密码&apos;,</span><br><span class="line">  `mobile`         varchar(20)       NOT NULL DEFAULT &apos;&apos; COMMENT &apos;手机&apos;,</span><br><span class="line">  `create_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6),</span><br><span class="line">  `update_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),</span><br><span class="line">  -- 创建唯一索引，不允许重复</span><br><span class="line">  UNIQUE INDEX idx_user_mobile(`mobile`)</span><br><span class="line">)</span><br><span class="line">ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">COMMENT=&apos;用户表信息&apos;;</span><br></pre></td></tr></table></figure><p>数据类型的属性解释</p><ul><li><code>NULL</code>：数据列可包含NULL值；</li><li><code>NOT NULL</code>：数据列不允许包含NULL值；</li><li><code>DEFAULT</code>：默认值；</li><li><code>PRIMARY</code>：KEY 主键；</li><li><code>AUTO_INCREMENT</code>：自动递增，适用于整数类型；</li><li><code>UNSIGNED</code>：是指数值类型只能为正数；</li><li><code>CHARACTER SET name</code>：指定一个字符集；</li><li><code>COMMENT</code>：对表或者字段说明；</li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><blockquote><p>SELECT 语句用于从表中选取数据。<br>语法：<code>SELECT 列名称 FROM 表名称</code><br>语法：<code>SELECT * FROM 表名称</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示id</span><br><span class="line">SELECT s.id from station s WHERE id in (13,14) and id not in (4);</span><br><span class="line"></span><br><span class="line">-- 从表 Persons 选取 LastName 列的数据</span><br><span class="line">SELECT LastName FROM Persons</span><br><span class="line"></span><br><span class="line">-- 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)</span><br><span class="line">SELECT * FROM users where id=3 limit 1</span><br><span class="line"></span><br><span class="line">-- 结果集中会自动去重复数据</span><br><span class="line">SELECT DISTINCT Company FROM Orders </span><br><span class="line">-- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，</span><br><span class="line">-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段</span><br><span class="line">SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P </span><br><span class="line"></span><br><span class="line">-- gbk 和 utf8 中英文混合排序最简单的办法 </span><br><span class="line">-- ci是 case insensitive, 即 “大小写不敏感”</span><br><span class="line">SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using gbk) collate gbk_chinese_ci;</span><br><span class="line">SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using utf8) collate utf8_unicode_ci;</span><br></pre></td></tr></table></figure><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><blockquote><p>Update 语句用于修改表中的数据。<br>语法：<code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- update语句设置字段值为另一个结果取出来的字段</span><br><span class="line">update user set name = (select name from user1 where user1 .id = 1 )</span><br><span class="line">where id = (select id from user2 where user2 .name=&apos;小苏&apos;);</span><br><span class="line">-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段</span><br><span class="line">UPDATE `orders` set title=&apos;这里是标题&apos; WHERE id=1;</span><br></pre></td></tr></table></figure><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><blockquote><p>INSERT INTO 语句用于向表格中插入新的行。<br>语法：<code>INSERT INTO 表名称 VALUES (值1, 值2,....)</code><br>语法：<code>INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghai</span><br><span class="line">INSERT INTO Persons (LastName, Address) VALUES (&apos;JSLite&apos;, &apos;shanghai&apos;);</span><br><span class="line">-- 向表 meeting 插入 字段 a=1 和字段 b=2</span><br><span class="line">INSERT INTO meeting SET a=1,b=2;</span><br><span class="line">-- </span><br><span class="line">-- SQL实现将一个表的数据插入到另外一个表的代码</span><br><span class="line">-- 如果只希望导入指定字段，可以用这种方法：</span><br><span class="line">-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;</span><br><span class="line">INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;</span><br><span class="line"></span><br><span class="line">-- 向表 charger 插入一条数据，已存在就对表 charger 更新 `type`,`update_at` 字段；</span><br><span class="line">INSERT INTO `charger` (`id`,`type`,`create_at`,`update_at`) VALUES (3,2,&apos;2017-05-18 11:06:17&apos;,&apos;2017-05-18 11:06:17&apos;) ON DUPLICATE KEY UPDATE `id`=VALUES(`id`), `type`=VALUES(`type`), `update_at`=VALUES(`update_at`);</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>DELETE 语句用于删除表中的行。<br>语法：<code>DELETE FROM 表名称 WHERE 列名称 = 值</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 在不删除table_name表的情况下删除所有的行，清空表。</span><br><span class="line">DELETE FROM table_name</span><br><span class="line">-- 或者</span><br><span class="line">DELETE * FROM table_name</span><br><span class="line">-- 删除 Person表字段 LastName = &apos;JSLite&apos; </span><br><span class="line">DELETE FROM Person WHERE LastName = &apos;JSLite&apos; </span><br><span class="line">-- 删除 表meeting id 为2和3的两条数据</span><br><span class="line">DELETE from meeting where id in (2,3);</span><br></pre></td></tr></table></figure><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><blockquote><p>WHERE 子句用于规定选择的标准。<br>语法：<code>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 从表 Persons 中选出 Year 字段大于 1965 的数据</span><br><span class="line">SELECT * FROM Persons WHERE Year&gt;1965</span><br></pre></td></tr></table></figure><h2 id="AND-和-OR"><a href="#AND-和-OR" class="headerlink" title="AND 和 OR"></a>AND 和 OR</h2><blockquote><p>AND - 如果第一个条件和第二个条件都成立；<br>OR - 如果第一个条件和第二个条件中只要有一个成立；</p></blockquote><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 删除 meeting 表字段 </span><br><span class="line">-- id=2 并且 user_id=5 的数据  和</span><br><span class="line">-- id=3 并且 user_id=6 的数据 </span><br><span class="line">DELETE from meeting where id in (2,3) and user_id in (5,6);</span><br><span class="line"></span><br><span class="line">-- 使用 AND 来显示所有姓为 &quot;Carter&quot; 并且名为 &quot;Thomas&quot; 的人：</span><br><span class="line">SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos;;</span><br></pre></td></tr></table></figure><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 OR 来显示所有姓为 &quot;Carter&quot; 或者名为 &quot;Thomas&quot; 的人：</span><br><span class="line">SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos;</span><br></pre></td></tr></table></figure><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><blockquote><p>语句默认按照升序对记录进行排序。<br><code>ORDER BY</code> - 语句用于根据指定的列对结果集进行排序。<br><code>DESC</code> - 按照降序对记录进行排序。<br><code>ASC</code> - 按照顺序对记录进行排序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Company在表Orders中为字母，则会以字母顺序显示公司名称</span><br><span class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company</span><br><span class="line"></span><br><span class="line">-- 后面跟上 DESC 则为降序显示</span><br><span class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC</span><br><span class="line"></span><br><span class="line">-- Company以降序显示公司名称，并OrderNumber以顺序显示</span><br><span class="line">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC</span><br></pre></td></tr></table></figure><h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><blockquote><p>IN - 操作符允许我们在 WHERE 子句中规定多个值。<br>IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。 语法：<code>SELECT &quot;字段名&quot;FROM &quot;表格名&quot;WHERE &quot;字段名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...);</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 从表 Persons 选取 字段 LastName 等于 Adams、Carter</span><br><span class="line">SELECT * FROM Persons WHERE LastName IN (&apos;Adams&apos;,&apos;Carter&apos;)</span><br></pre></td></tr></table></figure><h2 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h2><blockquote><p>NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = &apos;DLL01&apos; ORDER BY prod_name;</span><br></pre></td></tr></table></figure><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><blockquote><p>UNION - 操作符用于合并两个或多个 SELECT 语句的结果集。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名</span><br><span class="line">SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA</span><br><span class="line"></span><br><span class="line">-- 列出 meeting 表中的 pic_url，</span><br><span class="line">-- station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错</span><br><span class="line">-- 按更新时间排序</span><br><span class="line">SELECT id,pic_url FROM meeting UNION ALL SELECT id,number_station AS pic_url FROM station  ORDER BY update_at;</span><br><span class="line">-- 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序</span><br><span class="line">SELECT &apos;product&apos; AS type, count(*) as count FROM `products` union select &apos;comment&apos; as type, count(*) as count FROM `comments` order by count;</span><br></pre></td></tr></table></figure><h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><blockquote><p>as - 可理解为：用作、当成，作为；别名<br>一般是重命名列名或者表名。<br>语法：<code>select column_1 as 列1,column_2 as 列2 from table as 表</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Employee AS emp</span><br><span class="line">-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。</span><br><span class="line">-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.</span><br><span class="line">-- 例如 SELECT * FROM emp.</span><br><span class="line"></span><br><span class="line">SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders</span><br><span class="line">-- 列出表 Orders 字段 OrderPrice 列最大值，</span><br><span class="line">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</span><br><span class="line"></span><br><span class="line">-- 显示表 users_profile 中的 name 列</span><br><span class="line">SELECT t.name from (SELECT * from users_profile a) AS t;</span><br><span class="line"></span><br><span class="line">-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up</span><br><span class="line">-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id</span><br><span class="line">-- 结果集只显示mobile、name两列</span><br><span class="line">SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id;</span><br></pre></td></tr></table></figure><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><blockquote><p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p></blockquote><ul><li><code>JOIN</code>: 如果表中有至少一个匹配，则返回行</li><li><code>INNER JOIN</code>:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</li><li><code>LEFT JOIN</code>: 即使右表中没有匹配，也从左表返回所有的行</li><li><code>RIGHT JOIN</code>: 即使左表中没有匹配，也从右表返回所有的行</li><li><code>FULL JOIN</code>: 只要其中一个表中存在匹配，就返回行(MySQL 是不支持的，通过 <code>LEFT JOIN + UNION + RIGHT JOIN</code> 的方式 来实现)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line">FROM Persons</span><br><span class="line">INNER JOIN Orders</span><br><span class="line">ON Persons.Id_P = Orders.Id_P</span><br><span class="line">ORDER BY Persons.LastName;</span><br></pre></td></tr></table></figure><h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><blockquote><p>COUNT 让我们能够数出在表格中有多少笔资料被选出来。<br>语法：<code>SELECT COUNT(&quot;字段名&quot;) FROM &quot;表格名&quot;;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。</span><br><span class="line">-- &quot;IS NOT NULL&quot; 是 &quot;这个栏位不是空白&quot; 的意思。</span><br><span class="line">SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL; </span><br><span class="line">-- 获取 Persons 表的总数</span><br><span class="line">SELECT COUNT(1) AS totals FROM Persons;</span><br><span class="line">-- 获取表 station 字段 user_id 相同的总数</span><br><span class="line">select user_id, count(*) as totals from station group by user_id;</span><br></pre></td></tr></table></figure><h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><blockquote><p>MAX 函数返回一列中的最大值。NULL 值不包括在计算中。<br>语法：<code>SELECT MAX(&quot;字段名&quot;) FROM &quot;表格名&quot;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 列出表 Orders 字段 OrderPrice 列最大值，</span><br><span class="line">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</span><br><span class="line">SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><blockquote><p>语法： create trigger &lt;触发器名称&gt; { before | after} # 之前或者之后出发 insert | update | delete # 指明了激活触发程序的语句的类型 on &lt;表名&gt; # 操作哪张表 for each row # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。 &lt;触发器SQL语句&gt;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">CREATE TRIGGER set_userdate BEFORE INSERT </span><br><span class="line">on `message`</span><br><span class="line">for EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">  set @statu = new.status; -- 声明复制变量 statu</span><br><span class="line">  if @statu = 0 then       -- 判断 statu 是否等于 0</span><br><span class="line">    UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid;</span><br><span class="line">  end if;</span><br><span class="line">END</span><br><span class="line">$</span><br><span class="line">DELIMITER ; -- 恢复结束符号</span><br></pre></td></tr></table></figure><p>OLD和NEW不区分大小写</p><ul><li>NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。</li><li>OLD 用OLD.col_name来引用更新前的某一行的列</li></ul><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><h3 id="普通索引-INDEX"><a href="#普通索引-INDEX" class="headerlink" title="普通索引(INDEX)"></a>普通索引(INDEX)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD INDEX 索引名字 ( <code>字段名字</code> )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- –直接创建索引</span><br><span class="line">CREATE INDEX index_user ON user(title)</span><br><span class="line">-- –修改表结构的方式添加索引</span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br><span class="line">-- 给 user 表中的 name 字段 添加普通索引(INDEX)</span><br><span class="line">ALTER TABLE `user` ADD INDEX index_name (name)</span><br><span class="line">-- –创建表的时候同时创建索引</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line">    `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br><span class="line">-- –删除索引</span><br><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure><h3 id="主键索引-PRIMARY-key"><a href="#主键索引-PRIMARY-key" class="headerlink" title="主键索引(PRIMARY key)"></a>主键索引(PRIMARY key)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD PRIMARY KEY ( <code>字段名字</code> )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)</span><br><span class="line">ALTER TABLE `user` ADD PRIMARY key (id);</span><br></pre></td></tr></table></figure><h3 id="唯一索引-UNIQUE"><a href="#唯一索引-UNIQUE" class="headerlink" title="唯一索引(UNIQUE)"></a>唯一索引(UNIQUE)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD UNIQUE (<code>字段名字</code>)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)</span><br><span class="line">ALTER TABLE `user` ADD UNIQUE (creattime);</span><br></pre></td></tr></table></figure><h3 id="全文索引-FULLTEXT"><a href="#全文索引-FULLTEXT" class="headerlink" title="全文索引(FULLTEXT)"></a>全文索引(FULLTEXT)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD FULLTEXT (<code>字段名字</code>)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)</span><br><span class="line">ALTER TABLE `user` ADD FULLTEXT (description);</span><br></pre></td></tr></table></figure><h3 id="添加多列索引"><a href="#添加多列索引" class="headerlink" title="添加多列索引"></a>添加多列索引</h3><blockquote><p>语法： ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code>)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)</span><br><span class="line">ALTER TABLE user ADD INDEX name_city_age (name(10),city,age);</span><br></pre></td></tr></table></figure><h3 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h3><p>在<code>WHERE</code>和<code>JOIN</code>中出现的列需要建立索引，但也不完全如此：</p><ul><li>MySQL只对<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>BETWEEN</code>，<code>IN</code>使用索引</li><li>某些时候的<code>LIKE</code>也会使用索引。</li><li>在<code>LIKE</code>以通配符%和_开头作查询时，MySQL不会使用索引。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 此时就需要对city和age建立索引，</span><br><span class="line">-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。</span><br><span class="line">SELECT t.Name  </span><br><span class="line">FROM mytable t LEFT JOIN mytable m ON t.Name=m.username </span><br><span class="line">WHERE m.age=20 AND m.city=&apos;上海&apos;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM mytable WHERE username like&apos;admin%&apos;; -- 而下句就不会使用：</span><br><span class="line">SELECT * FROM mytable WHERE Name like&apos;%admin&apos;; -- 因此，在使用LIKE时应注意以上的区别。</span><br></pre></td></tr></table></figure><p>索引的注意事项</p><ul><li>索引不会包含有NULL值的列</li><li>使用短索引</li><li>不要在列上进行运算 索引会失效</li></ul><h2 id="创建后表的修改"><a href="#创建后表的修改" class="headerlink" title="创建后表的修改"></a>创建后表的修改</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><blockquote><p>语法：<code>alter table 表名 add 列名 列数据类型 [after 插入位置];</code></p></blockquote><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 在表students的最后追加列 address: </span><br><span class="line">alter table students add address char(60);</span><br><span class="line">-- 在名为 age 的列后插入列 birthday: </span><br><span class="line">alter table students add birthday date after age;</span><br><span class="line">-- 在名为 number_people 的列后插入列 weeks: </span><br><span class="line">alter table students add column `weeks` varchar(5) not null default &quot;&quot; after `number_people`;</span><br></pre></td></tr></table></figure><h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><blockquote><p>语法：<code>alter table 表名 change 列名称 列新名称 新数据类型;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 将表 tel 列改名为 telphone: </span><br><span class="line">alter table students change tel telphone char(13) default &quot;-&quot;;</span><br><span class="line">-- 将 name 列的数据类型改为 char(16): </span><br><span class="line">alter table students change name name char(16) not null;</span><br><span class="line">-- 修改 COMMENT 前面必须得有类型属性</span><br><span class="line">alter table students change name name char(16) COMMENT &apos;这里是名字&apos;;</span><br><span class="line">-- 修改列属性的时候 建议使用modify,不需要重建表</span><br><span class="line">-- change用于修改列名字，这个需要重建表</span><br><span class="line">alter table meeting modify `weeks` varchar(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;开放日期 周一到周日：0~6，间隔用英文逗号隔开&apos;;</span><br><span class="line">-- `user`表的`id`列，修改成字符串类型长度50，不能为空，`FIRST`放在第一列的位置</span><br><span class="line">alter table `user` modify COLUMN `id` varchar(50) NOT NULL FIRST ;</span><br></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><blockquote><p>语法：<code>alter table 表名 drop 列名称;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表students中的 birthday 列: </span><br><span class="line">alter table students drop birthday;</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><blockquote><p>语法：<code>alter table 表名 rename 新表名;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 重命名 students 表为 workmates: </span><br><span class="line">alter table students rename workmates;</span><br></pre></td></tr></table></figure><h3 id="清空表数据"><a href="#清空表数据" class="headerlink" title="清空表数据"></a>清空表数据</h3><blockquote><p>方法一：<code>delete from 表名;</code> 方法二：<code>truncate from &quot;表名&quot;;</code></p></blockquote><ul><li><code>DELETE:</code>1. DML语言;2. 可以回退;3. 可以有条件的删除;</li><li><code>TRUNCATE:</code>1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 清空表为 workmates 里面的数据，不删除表。 </span><br><span class="line">delete from workmates;</span><br><span class="line">-- 删除workmates表中的所有数据，且无法恢复</span><br><span class="line">truncate table workmates;</span><br></pre></td></tr></table></figure><h3 id="删除整张表"><a href="#删除整张表" class="headerlink" title="删除整张表"></a>删除整张表</h3><blockquote><p>语法：<code>drop table 表名;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除 workmates 表: </span><br><span class="line">drop table workmates;</span><br></pre></td></tr></table></figure><h3 id="删除整个数据库"><a href="#删除整个数据库" class="headerlink" title="删除整个数据库"></a>删除整个数据库</h3><blockquote><p>语法：<code>drop database 数据库名;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除 samp_db 数据库: </span><br><span class="line">drop database samp_db;</span><br></pre></td></tr></table></figure><h2 id="其它实例"><a href="#其它实例" class="headerlink" title="其它实例"></a>其它实例</h2><h3 id="SQL删除重复记录"><a href="#SQL删除重复记录" class="headerlink" title="SQL删除重复记录"></a>SQL删除重复记录</h3><p><a href="http://www.xiangguo.li/sql_and_nosql/2015/01/01/sql" target="_blank" rel="noopener">转载</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</span><br><span class="line">select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)</span><br><span class="line">-- 删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</span><br><span class="line">delete from people </span><br><span class="line">where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)</span><br><span class="line">and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1)</span><br><span class="line">-- 查找表中多余的重复记录（多个字段）</span><br><span class="line">select * from vitae a</span><br><span class="line">where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)</span><br><span class="line">-- 删除表中多余的重复记录（多个字段），只留有rowid最小的记录</span><br><span class="line">delete from vitae a</span><br><span class="line">where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1)</span><br><span class="line">-- 查找表中多余的重复记录（多个字段），不包含rowid最小的记录</span><br><span class="line">select * from vitae a</span><br><span class="line">where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1)</span><br></pre></td></tr></table></figure><h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><ul><li><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/sql/index.asp</a></li><li><a href="http://www.1keydata.com/cn/sql/sql-count.php" target="_blank" rel="noopener">http://www.1keydata.com/cn/sql/sql-count.php</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 入门资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法比较</title>
      <link href="/2019/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h2><p> <a href="https://www.nowcoder.com/discuss/85719" target="_blank" rel="noopener">原作者：opooc</a></p><h2 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h2><p><strong>时间复杂度：</strong></p><blockquote><p>反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。(下面用logN表示 log以2为底，N的对数)     </p></blockquote><p><strong>空间复杂度：</strong></p><blockquote><p>是指算法在计算机内执行时，所需额外开辟的空间。     </p></blockquote><p><strong>指标：</strong> </p><blockquote><p>同时间复杂度。     </p></blockquote><p><strong>常数项：</strong></p><blockquote><p>与N的大小无关的操作。     </p></blockquote><p><strong>稳定性：</strong></p><blockquote><p>(1)稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>(2)不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。     </p></blockquote><h2 id="2、算法分类"><a href="#2、算法分类" class="headerlink" title="2、算法分类"></a>2、算法分类</h2><blockquote><p><strong>十大经典排序算法可以分为两大类：</strong><br>0、非线性时间排序：通过比较来决定元素间的相对次序。时间复杂度最快为O(logN)<br>1、线性时间排序：通过创建有序的空间，将元素按照一定的规则放入有序空间，再依次取出。以空间来换取时间，可以突破O(logN)     </p></blockquote><ul><li>非线性时间排序         <ol><li>比较排序                 <ul><li>冒泡排序                     </li><li>快速排序                     </li></ul></li><li>插入排序                 <ul><li>插入排序                     </li><li>希尔排序                     </li></ul></li><li>选择排序                 <ul><li>选择排序                     </li><li>堆排序                     </li></ul></li><li>归并排序                 <ul><li>二路归并排序                     </li><li>多路归并排序                     </li></ul></li></ol></li><li>线性时间排序         <ol><li>计数排序             </li><li>堆排序             </li><li>基数排序             </li></ol></li></ul><h2 id="3、各算法的时间复杂度"><a href="#3、各算法的时间复杂度" class="headerlink" title="3、各算法的时间复杂度"></a>3、各算法的时间复杂度</h2><table><thead><tr><th>排序算法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>冒泡排序(外层优化)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>冒泡排序(外+内优化)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>快速排序(经典)</td><td>O(NlogNNlogN)</td><td>O(N2N2)</td><td>O(NlogNNlogN)</td><td>O(logNlogN)</td><td style="text-align:left">不稳定</td></tr><tr><td>快速排序(随机)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(logNlogN)</td><td style="text-align:left">不稳定</td></tr><tr><td>插入排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>希尔排序</td><td>O(N1.3N1.3)</td><td>O(N2N2)</td><td>O(NN)</td><td>O(11)</td><td style="text-align:left">稳定</td></tr><tr><td>选择排序</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(N2N2)</td><td>O(11)</td><td style="text-align:left">不稳定</td></tr><tr><td>堆排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(11)</td><td style="text-align:left">不稳定</td></tr><tr><td>二路归并排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NN)</td><td style="text-align:left">稳定</td></tr><tr><td>多路路归并排序</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NlogNNlogN)</td><td>O(NN)</td><td style="text-align:left">稳定</td></tr><tr><td>计数排序</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr><tr><td>桶排序</td><td>O(N+kN+k)</td><td>O(N2N2)</td><td>O(N+kN+k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr><tr><td>基数排序</td><td>O(N∗kN∗k)</td><td>O(N∗kN∗k)</td><td>O(N∗kN∗k)</td><td>O(N+kN+k)</td><td style="text-align:left">稳定</td></tr></tbody></table><h2 id="4、排序算法的实现"><a href="#4、排序算法的实现" class="headerlink" title="4、排序算法的实现"></a>4、排序算法的实现</h2><h3 id="0、通用函数及其他"><a href="#0、通用函数及其他" class="headerlink" title="0、通用函数及其他"></a>0、通用函数及其他</h3><blockquote><p>(0)、求数组长度（需要传数组，不要传数组指针）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里的注意点：在计算数组大小的时候，</span></span><br><span class="line"><span class="comment">   一定要注意传入的数组是否为数组指针，</span></span><br><span class="line"><span class="comment">   如果传入的是数组指针，sizeof后出来的值为8(64位下)，读者应注意。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(T&amp;amp; arr)</span></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(1)、交换数组两个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangee</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">/*   ^符号 即”异或“运算符，特点是与0异或，</span></span><br><span class="line"><span class="comment">  保持原值；与本身异或，结果为0。</span></span><br><span class="line"><span class="comment"> 这里可以使用位运算，交换时不用开辟额外空间。</span></span><br><span class="line"><span class="comment">  但是如果传入的'位置相同'的两个数，就不能在此函数中进行交 </span></span><br><span class="line"><span class="comment">  换。因为，自己跟自己异或后结果一定为0,就没有什么意义了。</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[b] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[a];</span><br><span class="line">arr[a] =  arr[b];</span><br><span class="line">arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> (2)、算法中的表达<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A代表平均时间复杂度</span><br><span class="line">* B代表最坏时间复杂度</span><br><span class="line">* E代表最好时间复杂度</span><br><span class="line">* 省略了O()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(3)、大数据样本下四钟最快算法的比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 数据是随机整数，时间单位是秒</span></span><br><span class="line"><span class="comment"> 数据规模|快速排序 归并排序 希尔排序 堆排序</span></span><br><span class="line"><span class="comment"> 1000万 |  0.75  1.221.773.57</span></span><br><span class="line"><span class="comment"> 5000万 |  3.78  6.299.4826.54</span></span><br><span class="line"><span class="comment"> 1亿|  7.65  13.06   18.79   61.31</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(4)、时间复杂度的大小比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> N!&gt;; x^N &gt;;...&gt;;3^N &gt;;2^N &gt;; N^x&gt;;...&gt;;N^3 &gt;;N^2&gt;;NlogN&gt;;N&gt;;logN&gt;;1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(5)数组和数组大小的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arrAndSize</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(6)初始化数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//一维 每个元素初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](<span class="number">0</span>);</span><br><span class="line"><span class="comment">//二维 每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//二维 每个一维中含N个数，N为确定的数值。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(N);</span><br><span class="line"><span class="comment">//通过动态创建的数组，要进行内存释放，否则内存将泄漏</span></span><br><span class="line"><span class="comment">//(本文中，未进行内存释放)</span></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(7)综合排序总结</p><ul><li>思考一个排序时候，考虑时间复杂度中的指标和常数项，空间复杂度，稳定性.</li></ul></blockquote><ul><li><p>代码规模，一定程度上说明了常数项的大小。（最终常数项的大小是看发生常数操作的次数）</p></li><li><p>系统的sort 方法，发现传进来的值为数值型，会使用快排，如果发现传的还有比较器，会使用归并排序</p></li><li><p><strong>归并和快排哪种更快？</strong><br>快排比归并排序的常数项要低，所以要快。</p></li><li><p><strong>为什么会有归并和快排两种呢？</strong><br>在比较的时候，使用比较器的时候，要追求一个稳定性，使用 归并排序 可以达稳定性的效果；使用快排不能够实现稳定性的效果。</p></li><li><p>面对大规模的时候，当排序量是小于等于60的时候，sort方法  会在内部使用插入排序的方法（不一定是60，是一定的规模）当数据量很低的时候，插入排序的常数项低。</p></li><li><p>在c语言中有一版，把归并排序，改成非递归，是基于工程其他考虑。</p></li></ul><blockquote><p>(8)对比两个数组是否相同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span> firstArr[],<span class="keyword">int</span> Second[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second != <span class="literal">nullptr</span>) ||(firstArr != <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len(firstArr) != len(Second)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len(firstArr); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (firstArr[i] != Second[i]) &#123;</span><br><span class="line"><span class="comment">//可以在此位置，打印错误项</span></span><br><span class="line"><span class="comment">//也可以打印整个数组查看错误项</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(9)复制数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">arrayCopy</span><span class="params">(<span class="keyword">int</span> oldArray[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oldArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* newArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i&lt;;length;i++) &#123;</span><br><span class="line">newArray[i] = oldArray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(10)产生随机数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arrAndSize <span class="title">generateRandomArr</span><span class="params">(<span class="keyword">int</span> maxSize,<span class="keyword">int</span> maxValue)</span></span>&#123;</span><br><span class="line"><span class="comment">//int arrrr =rand()%10;</span></span><br><span class="line">arrAndSize aAndS;</span><br><span class="line"><span class="keyword">int</span> size = (<span class="keyword">int</span>)((maxSize+<span class="number">1</span>) * (rand()%<span class="number">10</span>/(<span class="keyword">double</span>)<span class="number">10</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;;<span class="string">"&#123;"</span>&lt;;&lt;;size&lt;;&lt;;<span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt;; size;i++)&#123;</span><br><span class="line"><span class="comment">// 随机生成[-N,N];</span></span><br><span class="line"><span class="comment">//array[i] = (int)((maxValue +1) * (rand()%100)/(double)100) - (int)((maxValue + 1) * (rand()%100/(double)100));</span></span><br><span class="line"><span class="comment">//随机生成[0,N];</span></span><br><span class="line"> <span class="built_in">array</span>[i] = (<span class="keyword">int</span>)((maxValue +<span class="number">1</span>) * (rand()%<span class="number">10</span>)/(<span class="keyword">double</span>)<span class="number">10</span>);</span><br><span class="line"><span class="comment">//打印到底生成了什么。</span></span><br><span class="line"><span class="comment">//cout&lt;;&lt;;i&lt;;&lt;;"===="&lt;;&lt;;array[i] &lt;;&lt;;"|";</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;;&lt;;"+++++"&lt;;&lt;;endl;</span></span><br><span class="line">aAndS.size = size;</span><br><span class="line">aAndS.<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">return</span> aAndS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(11)疯狂递归 -递归master公式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 递归master公式</span></span><br><span class="line"><span class="comment"> T(N)的公式从大规模来看，不细分。</span></span><br><span class="line"><span class="comment"> T(N) = a * T(N/b)+O(n^d)</span></span><br><span class="line"><span class="comment"> N/b 是子过程数据量 ；a是子过程调用多少次；O(n^d)是出去</span></span><br><span class="line"><span class="comment"> 过程之外剩下的数据量的多少</span></span><br><span class="line"><span class="comment"> if log(b)a &gt;; d =&gt;; O(N^log(b)a)</span></span><br><span class="line"><span class="comment"> if log(b)a = d =&gt;; O(N^d *logN)</span></span><br><span class="line"><span class="comment"> if log(b)a &lt;; d =&gt;; O(N^d)</span></span><br><span class="line"><span class="comment"> 注意 多个递归的规模必须一样，否则master公式失效。</span></span><br><span class="line"><span class="comment">  例如一个规模是1/3;一个是2/3;</span></span><br><span class="line"><span class="comment"> 以下算法的时间复杂度：a = 2;b = 2;d = 0;所以时间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> arr[] ,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L ==  R) &#123;<span class="comment">//base case;</span></span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> LeftMax = process(arr, L, mid);</span><br><span class="line"><span class="keyword">int</span> RightMax = process(arr, mid+<span class="number">1</span> , R);</span><br><span class="line"><span class="keyword">return</span> (LeftMax /RightMax)?LeftMax  : RightMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInArray</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> process(arr , <span class="number">0</span> , length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>(12)比较器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按照年龄降序比较器</span></span><br><span class="line"><span class="comment"> 比较器使用的时候 不和java一样，c++中的比较器要注意返回值要为bool类型，</span></span><br><span class="line"><span class="comment">  而java中的返回值可以为int类型，根据两数相减进行判断下一步的排序。</span></span><br><span class="line"><span class="comment"> 比较器第一次比较完成后，下一次在比较的时候还是会含有第一次的排号的顺序，</span></span><br><span class="line"><span class="comment">  是利用了c++中sort函数的排序稳定性.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//比较器的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照年龄升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallAge</span><span class="params">(student s1,student s2)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里返回false的时候，相当于进行了一个交换操作</span></span><br><span class="line"><span class="keyword">return</span> s2.age &gt;; s1.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照班级升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallClassId</span><span class="params">(student s1, student s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s2.classId &gt;; s1.classId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">student s1 =  &#123;<span class="string">"opooc"</span>,<span class="number">21</span>,<span class="number">100</span>&#125;;</span><br><span class="line">student s2 =  &#123;<span class="string">"cat"</span>,<span class="number">30</span>,<span class="number">105</span>&#125;;</span><br><span class="line">student s3 =  &#123;<span class="string">"dog"</span>,<span class="number">1</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s4 =  &#123;<span class="string">"daolao"</span>,<span class="number">2</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s5 =  &#123;<span class="string">"dst"</span>,<span class="number">20</span>,<span class="number">103</span>&#125;;</span><br><span class="line">student allStudent[] =&#123;s1,s2,s3,s4,s5&#125;;</span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallAge);</span><br><span class="line"><span class="comment">//上面按照年龄升序后的结果，会继续在下面的班级降序中体现出来</span></span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallClassId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(13)vector容器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个一维容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;; v;</span><br><span class="line"><span class="comment">//声明一个二维数组，里面每个一维数组大小为10(必填)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; v1[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除最后添加的元素</span></span><br><span class="line">v.pop_back();</span><br><span class="line"><span class="comment">//删除向量中迭代器指向元素</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除向量中[first,last)中元素 如下删除1234位置</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>,v.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在第零个元素前面插1</span></span><br><span class="line">v.insert(v.begin(),<span class="number">1</span>);</span><br><span class="line"><span class="comment">//在第二个元素前插2</span></span><br><span class="line">v.insert(v.begin()+<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在最后一个元素后面插的10</span></span><br><span class="line">v.insert(v.end(),<span class="number">10</span>);</span><br><span class="line"><span class="comment">//元素的个数</span></span><br><span class="line">v.size();</span><br><span class="line"><span class="comment">//清除所有元素</span></span><br><span class="line">v.clear();</span><br><span class="line"><span class="comment">//遍历整个数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;:: iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>算法描述:</p><blockquote><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></blockquote><p>动画演示:</p><p><img alt="冒泡排序" src="https://img-blog.csdn.net/20180711042751164?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p></blockquote><h4 id="1-0、简单冒泡排序"><a href="#1-0、简单冒泡排序" class="headerlink" title="1.0、简单冒泡排序"></a>1.0、简单冒泡排序</h4><blockquote><p>（交换排序;时间A:N^2 ,B:N^2 ,E:N^2 ;空间1;稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;;length - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="1-1、外层循环优化冒泡排序"><a href="#1-1、外层循环优化冒泡排序" class="headerlink" title="1.1、外层循环优化冒泡排序"></a>1.1、外层循环优化冒泡排序</h4><blockquote><p>(交换排序; 时间A:N^2 , B:N^2 , E:N; 空间1; 稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用一个flag来判断一下，当前数组是否已经有序,</span></span><br><span class="line"><span class="comment">  有序就退出循环，可以提高冒泡排序的性能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;;length; i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; length -i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j]&gt;;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">flag  =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="1-2、内层循环优化冒泡排序"><a href="#1-2、内层循环优化冒泡排序" class="headerlink" title="1.2、内层循环优化冒泡排序"></a>1.2、内层循环优化冒泡排序</h4><blockquote><p>(交换排序; 时间A:N^2 , B:N^2 , E:N ; 空间1 ; 稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)完美冒泡</span></span><br><span class="line"><span class="comment">(2)再用last标记一下最后一个发生交换的数，</span></span><br><span class="line"><span class="comment">   下次可以减少循环次数。其中第一次内部循环的控制条件，单独拿出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>算法描述:</p><blockquote><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><p>动画演示:<br><img alt="快速排序" src="https://img-blog.csdn.net/20180711042825711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法流程如下：<br>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></blockquote><h4 id="2-0、随机快速排序"><a href="#2-0、随机快速排序" class="headerlink" title="2.0、随机快速排序"></a>2.0、随机快速排序</h4><blockquote><p>（交换排序;时间A:NlogN,B:NlogN,E:NlogN;空间logN;不稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)in-place原地算法可以实现 把以划分值为标准，</span></span><br><span class="line"><span class="comment">       小于等于划分值的放左边并推着大于划分值的数向右走。</span></span><br><span class="line"><span class="comment">       时间复杂度O(N)空间复杂度是O（1）</span></span><br><span class="line"><span class="comment">    (2)（荷兰国旗问题）在实现把等于划分值的放中间，小于</span></span><br><span class="line"><span class="comment">        划分值的放左边，大于划分值的放右边且时间复杂度O(N)</span></span><br><span class="line"><span class="comment">        空间复杂度仍未O(1)的时候。1.当前数&lt;p左区下一个</span></span><br><span class="line"><span class="comment">        交换，左区扩，检测下一个。2、当前数等于p，检测下</span></span><br><span class="line"><span class="comment">        一个。3、当前数大于p，和右区前一个位置换，右区扩。</span></span><br><span class="line"><span class="comment">        继续检测当前换完的数。</span></span><br><span class="line"><span class="comment">    (3) 其中的空间复杂度是不得不使用的空间，用来记录每次的左右边界。</span></span><br><span class="line"><span class="comment">    (4)快速排序可以做到稳定，但是非常难，可以搜 0-1stable sort论文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">separate</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first  = left <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Second = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; Second) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, ++first, left++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, --Second, left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]==arr[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exchangee(arr, Second, right);</span><br><span class="line">    <span class="keyword">int</span> firstAndSecond[<span class="number">2</span>] = &#123;first+<span class="number">1</span>,Second&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> firstAndSecond;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> randomC = (<span class="keyword">int</span>)((rand()%<span class="number">100</span>/(<span class="keyword">double</span>)<span class="number">100</span>) * (right - left +<span class="number">1</span>));</span><br><span class="line">        exchangee(arr,left+ randomC, right);</span><br><span class="line">        <span class="keyword">int</span>* curArr  = separate(arr, left, right);</span><br><span class="line">        quickSort(arr, left,curArr[<span class="number">0</span>] <span class="number">-1</span> );</span><br><span class="line">        quickSort(arr, curArr[<span class="number">1</span>]+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>]=&#123;<span class="number">99</span>,<span class="number">11</span>,<span class="number">72</span>,<span class="number">62</span>,<span class="number">53</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">21</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = len(arr);</span><br><span class="line">    quickSort(arr,length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="2-1、小和问题"><a href="#2-1、小和问题" class="headerlink" title="2.1、小和问题"></a>2.1、小和问题</h4><p>问题描述</p><blockquote><p>求小和问题：在随机元素，随机数组大小的数组中，找出左边比右边元素小的所有元素之和。<br>例如：数组[4,2,5,1,7,3,6] 第一个元素4比2大，不算小和，5比4和2都大，那就是4+2=6；1比4和2和5都小，不算小和；7比前面的都大，那就是上次小和6+4+2+5+1=18；然后3前面比2和1大，那就是18+2+1=21；最后6比4、2、5、1、3都大，结果就是21+4+2+5+1+3=36。那么最后的结果就是36。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> *help = <span class="keyword">new</span> <span class="keyword">int</span>(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;=mid &amp;&amp; pSecond &lt;=R) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在左右两个区有谁小谁移动的原则</span></span><br><span class="line"><span class="comment">        看小和问题和逆序对问题时，要抓住一边分析。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">      （小和问题，因为要统计左区小于右区的数的数量，</span></span><br><span class="line"><span class="comment">      既统计左区比右区小的数，因为在排序的时候，左区可能会移动，</span></span><br><span class="line"><span class="comment">      故左区在移动后，无法在下一步查看右区大于的数，</span></span><br><span class="line"><span class="comment">      所以要一次性把针对左区当前数大的数全部记录下来</span></span><br><span class="line"><span class="comment">        逆序对问题，则需要一个一个记录左区比右区大的数。）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sum += arr[pFirst] &lt; arr[pSecond] ? arr[pFirst]*(R-pSecond+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">        help[i++]  = arr[pFirst] &lt; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;= mid ) &#123;</span><br><span class="line">        help[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (R-L+<span class="number">1</span>); k++) &#123;</span><br><span class="line">        arr[L+k] = help[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L==R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>  mid = L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">//  相当于  int  mid = L+(R-L)/2;</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = smallSum(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightSum = smallSum(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">int</span> leftAndRightSum = allSum(arr,L,mid,R);</span><br><span class="line">    <span class="keyword">return</span>  leftSum + rightSum + leftAndRightSum;</span><br><span class="line"><span class="comment">//    return smallSum(arr, L, mid)+smallSum(arr, mid + 1, R)+allSum(arr,L,mid,R);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span> <span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">nullptr</span> || length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum(arr,<span class="number">0</span>,length <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-0、插入排序"><a href="#3-0、插入排序" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h3><p>算法描述:</p><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></blockquote><p>动画演示:<br><img alt="插入排序" src="https://img-blog.csdn.net/20180711042900649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>一般来说，插入排序都采用in-place在数组上实现。具体算法流程如下：<br>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；<br>重复步骤2~5。</p></blockquote><h4 id="3-0、插入排序-1"><a href="#3-0、插入排序-1" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h4><blockquote><p>(插入排序;时间A:N^2 , B:N^2 , E:N;空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、在对比的时候不交换；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;; length;i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span>&amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以直接交换。因为current记录了最后一个值，</span></span><br><span class="line"><span class="comment">            所以这里使用向后移动思想。</span></span><br><span class="line"><span class="comment">            exchangee(arr, preIndex, current);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex --;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法二、在对比的时候进行交换；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j&gt;;=<span class="number">0</span> &amp;amp;&amp;amp; arr[j]&gt;;arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><p>算法描述:</p><blockquote><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p></blockquote><p>动画演示:<br><img alt="希尔排序" src="https://img-blog.csdn.net/20180711042930449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法流程：<br>选择一个增量序列t1，t2，…，tk，其中ti&gt;;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></blockquote><h4 id="4-0、希尔排序"><a href="#4-0、希尔排序" class="headerlink" title="4.0、希尔排序"></a>4.0、希尔排序</h4><blockquote><p>(插入排序;时间A:N^1.3 , B:N^2 , E:N;空间1;不稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (又称缩小增量排序)</span></span><br><span class="line"><span class="comment">    通过实验，大量本表现出，平均时间复杂度为N^1.3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> gap = length;</span><br><span class="line">    <span class="keyword">while</span> (gap&gt;;<span class="number">1</span>)&#123;</span><br><span class="line">        gap = gap/<span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i&lt;;length; i+=gap) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span> &amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">                arr[i]  = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex+gap] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h3><p>算法描述:</p><blockquote><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><p>动画演示:<br><img alt="选择排序" src="https://img-blog.csdn.net/20180711042950325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>实现逻辑:</p><blockquote><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法流程如下：<br>初始状态：无序区为R[1..n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p></blockquote><h4 id="5-0、选择排序"><a href="#5-0、选择排序" class="headerlink" title="5.0、选择排序"></a>5.0、选择排序</h4><blockquote><p>(选择排序;时间A:N^2 , B:N^2 , E:N^2 ; 空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;length<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;   <span class="keyword">int</span> minIndex =i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;;length;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h3><p>算法描述:</p><blockquote><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>动画演示:<br><img alt="堆排序" src="https://img-blog.csdn.net/20180711043016142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p></blockquote><p>实现逻辑:</p><blockquote><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p></blockquote><h4 id="6-0、堆排序"><a href="#6-0、堆排序" class="headerlink" title="6.0、堆排序"></a>6.0、堆排序</h4><blockquote><p>(选择排序;时间A:NlogN,B:NlogN,E:NlogN;空间1;不稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">        堆的概念：对于大根堆，其子树下的所有节点，</span><br><span class="line">     包括它自己在内的最大值为头结点。</span><br><span class="line">        时间复杂度为0+log1+log2+……数学上可以证明</span><br><span class="line">     这个值收敛于O(N)</span><br><span class="line">*/</span><br><span class="line">//向上走</span><br><span class="line">void heapInsert(int arr[],int index)&#123;</span><br><span class="line">    while (arr[index] &gt;; arr[(index-1)/2]) &#123;</span><br><span class="line">        exchangee(arr,index, (index-1)/2);</span><br><span class="line">        index = (index -1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//向下走</span><br><span class="line">//size为最右的边界，size是取不到的.</span><br><span class="line">void heapify(int arr[],int index ,int size)&#123;</span><br><span class="line">    int leftChild = index*2 + 1;</span><br><span class="line">    while (leftChild &lt;; size) &#123;</span><br><span class="line">        int maxChild = leftChild + 1 &lt;; size &amp;amp;&amp;amp; arr[leftChild+1] &gt;;arr[leftChild] ? leftChild+1 : leftChild;</span><br><span class="line">        int maxAll = arr[maxChild] &gt;; arr[index] ? maxChild: index;</span><br><span class="line">        if (maxAll  == index) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, maxAll, index);</span><br><span class="line">        index = maxAll;</span><br><span class="line">        leftChild = index*2 +1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0;i &lt;;length;i++)&#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    int size = length;</span><br><span class="line">    exchangee(arr, 0, --size);</span><br><span class="line">    while (size &gt;; 0)&#123;</span><br><span class="line">        //heapify时间复杂度为O(logN)</span><br><span class="line">        heapify(arr, 0, size);</span><br><span class="line">        exchangee(arr, 0, --size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><p>算法描述:</p><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p>动画演示:<br><img alt="归并排序" src="https://img-blog.csdn.net/20180711043050105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p></blockquote><h4 id="7-0、二路归并排序"><a href="#7-0、二路归并排序" class="headerlink" title="7.0、二路归并排序"></a>7.0、二路归并排序</h4><blockquote><p>(插入排序;时间A:N<em>logN,B:N</em>logN,E:N*logN;空间N;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    归并排序内部缓存法 可以把空间复杂度降到O(1)；</span></span><br><span class="line"><span class="comment">    归并排序原地归并法 也可以把空间复杂度降到O(1)但是时间复</span></span><br><span class="line"><span class="comment">    杂度会变成O(N^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> M,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* cent = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M &amp;amp;&amp;amp; pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst] &lt;; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; (R-L+<span class="number">1</span>); j++) &#123;</span><br><span class="line">        arr[L+j] = cent[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, L, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || length&lt;;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(<span class="built_in">array</span>,<span class="number">0</span>,length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h3><p>算法描述:</p><blockquote><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p></blockquote><p>动画演示:<br><img alt="计数排序" src="https://img-blog.csdn.net/20180711043148643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>对所有的计数累加(从桶中的第0个元素开始，每一项和前一项相加);<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项,<br>每放一个元素就将C(i)减去1，是为了保证算法的稳定性。</p></blockquote><h4 id="8-0、计数排序"><a href="#8-0、计数排序" class="headerlink" title="8.0、计数排序"></a>8.0、计数排序</h4><blockquote><p>(计数排序;时间A:N+k,B:N+k,E:N+k;空间N+k;稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*    输入的元素是 n 个 0到 k 之间的整数</span><br><span class="line">      当k不是很大并且序列比较集中时，计数排序是一个很有效的</span><br><span class="line">   排序算法。</span><br><span class="line">      下面算法是输入的数组中的最小值大于等于0的情况，</span><br><span class="line">   可以根据需求更改。    </span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void countSort(int arr[] ,int length)&#123;</span><br><span class="line">    int max = arr[0];</span><br><span class="line">    int lastIndex=  0;</span><br><span class="line">    for (int i = 1; i&lt;;length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    int* sortArr  = new int[max+1]();</span><br><span class="line">    for (int j = 0; j&lt;; length; j++) &#123;</span><br><span class="line">        sortArr[arr[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int k = 0; k&lt;;max+1; k++) &#123;</span><br><span class="line">        while (sortArr[k]&gt;;0) &#123;</span><br><span class="line">            arr[lastIndex++] = k;</span><br><span class="line">            sortArr[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h3><p>算法描述:</p><blockquote><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p></blockquote><p>图片演示:<br><img alt="桶排序" src="https://img-blog.csdn.net/201807110432136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。</p></blockquote><h4 id="9-0、桶排序"><a href="#9-0、桶排序" class="headerlink" title="9.0、桶排序"></a>9.0、桶排序</h4><blockquote><p>桶排序(时间A:N+k,B:N^2,E:N+k;空间N+k;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序是: 桶思想排序 + 一个普通的排序（常用快速排序）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark bucketSort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//size  为一个桶的囊括的数的范围</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到最大最小值</span></span><br><span class="line">    <span class="keyword">long</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">long</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i] &lt;; min ? arr[i]: min;</span><br><span class="line">        max = arr[i] &gt;; max ? arr[i]: max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最小值等于最大值说明数组中就一种数</span></span><br><span class="line">    <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>)((max -min)/size +<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(bucketCount);</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把数组中的数 扔进桶里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;  i &lt;; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        bid = getGroupCount(arr[i], bucketCount, min, max);</span><br><span class="line">        bucket[bid].push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;; bucketCount; i++) &#123;</span><br><span class="line">        <span class="comment">//对桶内进行插入排序。按照升序，这样可以保证从下往上读的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (bucket[i][j] &lt;; bucket[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(bucket[i][j],bucket[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;; bucket[i].size(); t++) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;;&lt;;bucket[i][t]&lt;;&lt;;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    int *newArr = new int[len];</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;bucketCount ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            arr[index++] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="9-1、桶排序思想"><a href="#9-1、桶排序思想" class="headerlink" title="9.1、桶排序思想"></a>9.1、桶排序思想</h4><p>问题描述</p><blockquote><p>数组最大值问题。<br>给定一个无序数组，求如果排序之后，相邻两数的最大差值，<br>要求时间复杂度O（N），且要求不能用基于比较的排序。<br>以此题发现桶排序妙趣思想.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size<span class="number">-1</span>)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxGroup</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到系统的最大值和系统的最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i]&lt;;min ? arr[i]:min;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* maxValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>* minValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span>* flag = <span class="keyword">new</span> <span class="keyword">bool</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;;len; j++) &#123;</span><br><span class="line">        bid = getGroupCount(arr[j], len, min, max);</span><br><span class="line">        minValue[bid] = minValue[bid]? (minValue[bid]&lt;;arr[j]?minValue[bid]:arr[j]):arr[j];</span><br><span class="line">        maxValue[bid] = maxValue[bid]? (maxValue[bid]&gt;;arr[j]?maxValue[bid]:arr[j]):arr[j];</span><br><span class="line">        flag[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k= <span class="number">1</span> ; k&lt;;len+<span class="number">1</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[k]) &#123;</span><br><span class="line">            res = res &gt;; (minValue[k] - maxValue[lastMax]) ? res :(minValue[k] - maxValue[lastMax]);</span><br><span class="line">            lastMax =k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h3><p>算法描述:</p><blockquote><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p></blockquote><p>动画演示:<br><img alt="基数排序" src="https://img-blog.csdn.net/20180711043311284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p><p>实现逻辑:</p><blockquote><p>取得数组中的最大数，并取得位数；&lt;br /<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p></blockquote><h4 id="10-0、基数排序"><a href="#10-0、基数排序" class="headerlink" title="10.0、基数排序"></a>10.0、基数排序</h4><blockquote><p>(基数排序;时间A:N <em> k , B:N </em> k , E:N * k ; 空间N+k ; 稳定)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到传入数的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRadixCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count /<span class="number">10</span> &gt;;<span class="number">0</span>) &#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到10的传入位数的次方(10^num)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTenRadixCount</span><span class="params">(<span class="keyword">int</span> radixCount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tenRadix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (radixCount &gt;; <span class="number">0</span> ) &#123;</span><br><span class="line">        tenRadix *= <span class="number">10</span>;</span><br><span class="line">        radixCount --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tenRadix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;; length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> radixCount = getRadixCount(max);</span><br><span class="line">    <span class="keyword">int</span> tenRadixCount = getTenRadixCount(radixCount);</span><br><span class="line">    <span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>* num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();</span><br><span class="line">    <span class="keyword">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (multiplier &lt;; tenRadixCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curCount = arr[i]/multiplier%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> k = num[curCount];</span><br><span class="line">            bucket[curCount][k] = arr[i];</span><br><span class="line">            num[curCount]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">0</span>; k&lt;;num[j]; k++) &#123;</span><br><span class="line">                    arr[index++]  =  bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把桶清空，准备下一次循环。</span></span><br><span class="line">            num[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        multiplier *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法学习</title>
      <link href="/2019/04/11/python%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/11/python%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><ul><li>单双引号皆可,如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来,如果既包括<code>&#39;&#39;</code>又包括<code>&quot;&quot;</code>,那么就使用转义字符来标识</li><li>通过<code>input()</code>输入进来的所有东西默认是一个字符串</li><li><p><code>print()</code>在列表里输出遇到<code>&quot;,&quot;</code>时会输出一个空格</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'asd'</span>,<span class="string">"asd"</span>)</span><br><span class="line">asd asd</span><br></pre></td></tr></table></figure></li><li><p>可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></li><li><p>如果有很多换行，用<code>\n</code>写在一行里不好阅读，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line"><span class="comment"># 上面是在交互式命令行内输入。在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入</span></span><br></pre></td></tr></table></figure><blockquote><p>   <strong>注意!!!</strong> <code>...</code> 是提示符，不是代码的一部分：</p></blockquote></li></ul><h1 id="数据类型与变量"><a href="#数据类型与变量" class="headerlink" title="数据类型与变量"></a>数据类型与变量</h1><ul><li><p>Python是<strong>大小写敏感</strong>的</p></li><li><p><code>None</code>是python中一个特殊的值——<strong>空值</strong>，None不能理解为0，因为0是有意义的，而None是一个特殊的空值</p></li><li><p>可以把<strong>任意数据类型</strong>赋值给变量，<strong>同一个变量</strong>可以被赋值为<strong>不同类型的数据</strong></p></li></ul><blockquote><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。<br>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p></blockquote><ul><li><p>Python中，<code>/</code>除法计算结果是<strong>浮点数</strong>，即使是两个整数<strong>恰好整除，结果也是浮点数</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span>/<span class="number">3</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure></li><li><p>还有一种除法是<code>//</code>，称为<code>地板除</code>，两个整数的除法仍然是整数 <strong>(即使除不尽)</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span>//<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>Python的<strong>整数没有大小限制</strong></p></li><li>浮点数也没有大小限制，但是<strong>超出一定范围</strong>就直接表示为<code>inf</code></li></ul><h1 id="字符串与编码"><a href="#字符串与编码" class="headerlink" title="字符串与编码"></a>字符串与编码</h1><ul><li><p><code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>) <span class="comment"># 也可用十六进制</span></span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure></li><li><p>在知道字符整数编码的情况下，还可以用<strong>十六进制</strong>这么写字符</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span></span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p><code>bytes</code>的每个字符只占用一个字节</p></li><li>使用<code>encode()</code>将Unicode字符编码为<code>bytes</code>，使用<code>decode()</code>将其重新变为<code>str</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt中的setWindowFlags方法</title>
      <link href="/2019/03/10/Qt%E4%B8%AD%E7%9A%84setWindowFlags%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/10/Qt%E4%B8%AD%E7%9A%84setWindowFlags%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt中的setWindowFlags方法"><a href="#Qt中的setWindowFlags方法" class="headerlink" title="Qt中的setWindowFlags方法"></a>Qt中的setWindowFlags方法</h1><p>在Qt中，可使用setWindowFlags方法对窗口进行一些特殊属性的设置，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint);<span class="comment">//去掉窗口边框</span></span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);<span class="comment">//窗口置顶</span></span><br></pre></td></tr></table></figure></p><p>当多次使用该方法时，之后的修改会<strong>覆盖</strong>掉之前的结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint);</span><br><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);</span><br><span class="line"><span class="comment">//产生一个置顶的有边框的窗口（去边框的效果被覆盖掉）</span></span><br></pre></td></tr></table></figure></p><p>所以，如果想用setWindowFlags同时实现多种效果,应该这样写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint|Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure></p><p>使用“|”可实现多种效果同时出现，有点类似金工实习里遇到的那个电梯模型的多状态设置。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Qt </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二寒假日常记录（持续更新中...）</title>
      <link href="/2019/01/19/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/19/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Status to be updated…<br><a id="more"></a></p><h1 id="理论-算法方面"><a href="#理论-算法方面" class="headerlink" title="理论/算法方面"></a>理论/算法方面</h1><p>学习中…</p><h1 id="项目方面"><a href="#项目方面" class="headerlink" title="项目方面"></a>项目方面</h1><p>积极筹备中…</p><h1 id="比赛方面"><a href="#比赛方面" class="headerlink" title="比赛方面"></a>比赛方面</h1><h2 id="节能减排大赛"><a href="#节能减排大赛" class="headerlink" title="节能减排大赛"></a>节能减排大赛</h2><p>造数据！</p><p><strong>造数据！！</strong></p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>先划水半个月…</p><h1 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h1><p>Nothing</p><h1 id="每日记录"><a href="#每日记录" class="headerlink" title="每日记录"></a>每日记录</h1><table><thead><tr><th style="text-align:center">日 期</th><th style="text-align:center">理 论 / 算 法</th><th style="text-align:center">项 目 / coding / 实 践</th><th style="text-align:center">杂 活 儿</th><th style="text-align:center">生 活 / 备 注</th></tr></thead><tbody><tr><td style="text-align:center">1.19</td><td style="text-align:center">Markdown语法学习</td><td style="text-align:center">Blog新域名+国内DNS+https</td><td style="text-align:center">整理美术素材</td><td style="text-align:center">假期开始          </td></tr><tr><td style="text-align:center">1.20</td><td style="text-align:center">了解MVC框架相关知识</td><td style="text-align:center">帮学弟改代码(快速排序优化)<br>网站搭建后续工作</td><td style="text-align:center">更新博文</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.21</td><td style="text-align:center">Hexo框架学习</td><td style="text-align:center">改网站的bug…<br>博客换用新框架</td><td style="text-align:center">整理美术素材</td><td style="text-align:center">被空格不断制裁Orz…</td></tr><tr><td style="text-align:center">1.22</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">请灵，守夜<br>心情不好没干事</td></tr><tr><td style="text-align:center">1.23</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">爷爷去世一周年忌日<br>心情不好继续休息</td></tr><tr><td style="text-align:center">1.24</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.25</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">聚会</td></tr><tr><td style="text-align:center">1.26</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">身体不适，效率低下</td></tr><tr><td style="text-align:center">1.27</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">开始构思UI方案</td><td style="text-align:center">-</td><td style="text-align:center">仍然效率低下</td></tr><tr><td style="text-align:center">1.28</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">整理各种文件和资源</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.29</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">进行开发准备工作</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.30</td><td style="text-align:center">-</td><td style="text-align:center">工具/API准备工作</td><td style="text-align:center">收到ZF老师短信，安排进组前的假期学习任务</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1.31</td><td style="text-align:center">-</td><td style="text-align:center">消息推送模块开发</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.1</td><td style="text-align:center">Java知识学习</td><td style="text-align:center">算法题目*3</td><td style="text-align:center">-</td><td style="text-align:center">理发</td></tr><tr><td style="text-align:center">2.2</td><td style="text-align:center">动态规划</td><td style="text-align:center">补注释</td><td style="text-align:center">收集算法学习资源</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.3</td><td style="text-align:center">各类排序优化<br>哈希算法</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.4</td><td style="text-align:center">搜索剪枝优化</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.5</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">过年</td></tr><tr><td style="text-align:center">2.6</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">过年</td></tr><tr><td style="text-align:center">2.7~<br>2.14</td><td style="text-align:center">-</td><td style="text-align:center">项目开发前期工作</td><td style="text-align:center">-</td><td style="text-align:center">去乡下</td></tr><tr><td style="text-align:center">2.15</td><td style="text-align:center">并查集</td><td style="text-align:center">-</td><td style="text-align:center">整理素材，写文档</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2.16</td><td style="text-align:center">SQL知识学习</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法学习</title>
      <link href="/2019/01/19/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/19/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇Markdown文档"><a href="#这是一篇Markdown文档" class="headerlink" title="这是一篇Markdown文档"></a>这是一篇Markdown文档</h1><h2 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h2><p>我是一段正文，会有<strong>关键字</strong>，另外<del>不关键的句子我会删掉</del></p><hr><p>这是第二段正文，在这里会有一个<em>斜体关键字</em>，还会有一个<code>内嵌代码块</code>，完美！下一行会有一个引用</p><blockquote><p>我是一行引用。——鲁迅</p><p>我也是。——周树人</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>接下来试验列表，先是无序的</p><ul><li>无序列表</li><li>我也是</li><li>me too</li></ul><hr><p>下边是有序的</p><ol><li>比如我</li><li>and me</li><li>ho!</li></ol><h3 id="突然发现还可以嵌套"><a href="#突然发现还可以嵌套" class="headerlink" title="突然发现还可以嵌套"></a>突然发现还可以嵌套</h3><blockquote><ul><li>外层<ul><li>内层</li><li>我也是内层<ul><li>内层的内层</li></ul></li></ul></li><li>第二个外层</li></ul></blockquote><h3 id="果然有序的也可以"><a href="#果然有序的也可以" class="headerlink" title="果然有序的也可以"></a>果然有序的也可以</h3><blockquote><ol><li>外层<ol start="2"><li>内层</li><li>我也是内层<ol start="4"><li>内层的内层</li></ol></li></ol></li><li>第二个外层</li></ol></blockquote><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下边我会写一些代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来试验超链接，这是我的<a href="https://ranchoturing.com" target="_blank" rel="noopener">个人博客链接</a><br>这是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a>,这也是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a>,这还是<a href="https://ranchoturing.com" title="rancho&#39;s blog" target="_blank" rel="noopener">博客</a></p><p>在这儿可以插一张图片<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="图片"></p><p>这样插图片也行<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="一张图片">,再次<img src="http://www.turingbook.com/Content/img/Turing.Gif" alt="一张图片"></p><p>链接也可以用索引的方式存在后边，算是行内式和参考式超链接的一种混合运用，如：<a href="https://ranchoturing.com" target="_blank" rel="noopener">建国的小屋</a></p><p>另外，还有自动链接，来处理网址和邮箱地址之类的，如<a href="mailto:&#51;&#x31;&#51;&#53;&#x36;&#49;&#51;&#52;&#52;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#51;&#x31;&#51;&#53;&#x36;&#49;&#51;&#52;&#52;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这个真的是最麻烦的了，所以用最简单的格式写就好，注意对齐</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">一斤多少钱呀</th><th style="text-align:right">到底要买多少呢</th></tr></thead><tbody><tr><td style="text-align:center">超大超好吃的苹果</td><td style="text-align:center">5.0</td><td style="text-align:right">33</td></tr><tr><td style="text-align:center">绿色的香蕉</td><td style="text-align:center">8.8</td><td style="text-align:right">25</td></tr><tr><td style="text-align:center">梨子</td><td style="text-align:center">6.5</td><td style="text-align:right">10</td></tr></tbody></table><h2 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h2><ul><li style="list-style: none"><input type="checkbox" checked> get</li><li style="list-style: none"><input type="checkbox"> can’t</li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站感言</title>
      <link href="/2019/01/04/build-site/"/>
      <url>/2019/01/04/build-site/</url>
      
        <content type="html"><![CDATA[<ul><li style="list-style: none"><input type="checkbox" checked> 个人网站</li><li style="list-style: none"><input type="checkbox" checked> 一年份的域名 </li></ul><p>按照惯例干了好事/ 坏事要写小作文来记录，<del>趁热打铁先写在空间，等白天电脑有电了再更新到网站上</del></p><p>经过一晚上的折腾，终于差不多搞定了网站，并且赶在没电关机的前几秒截了图。<br><a id="more"></a></p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>一直以来，被好多学长和前辈提醒过要写博客记录学习进度才能有收获。</p><p>但由于各（fei）种（chang）原（de）因（lan），在其他同学不断写博客更新刷题笔记、分享技术的时候，我还一直停留在用本地的文本文档记随笔的阶段。github上没有一行代码、csdn的博客里只写了一篇开头，<del>还开坑不填</del>。</p><p>仔细想想，近一年来还是学到/接触了不少值得记录下来的东西的。如果好好写写博客梳理一下，肯定会有很多新的收获。</p><p>所以，大概一两个月前就开始准备好好整理一下电脑上的随笔，更到博客里。结果没过几天，就被csdn坑了一把，见识到了<strong>辣鸡</strong>csdn捞钱时的丑恶嘴脸，从此粉转黑。（当然，更博的计划也就被我以这个理由暂时搁置了。嗯，这个理由很正当，没毛病，<strong>绝对不是我想偷懒</strong></p><p>之后又试了下欧阳之前推荐过的cnblog，功能虽然很强大，但还停留在零几年的老旧的界面风格实在是让人感觉很难受，所以就放弃了cnblog，开始打起了自己写个个人网站的主意。</p><h2 id="着手准备"><a href="#着手准备" class="headerlink" title="着手准备"></a>着手准备</h2><p>一开始是打算自己从头开始写的，但是具有知难而退的良好品质的我果断就放弃了这个想法，开始寻找一些开源的框架和方案。不得不说，站在巨人的肩膀上确实是一件幸福的事，在计算机领域，由于大家对“开源精神”的推崇，这种幸福更是被无限地放大了，很多问题都能找到前辈们留下的解决方案，新问题也能得到大佬们热心的解答。</p><p>当时的想法是把网站托管在github上，也省去了自己购买和配置服务器与域名的麻烦和开销。多方考虑之下，放弃了写动态网页的打算而选择了静态网页，之后又选择放弃hexo，选择了Jekyll来开发。所以最近的一段时间基本没有写题训练，偷懒之余，一直在学习git和这些方面的东西。</p><p>不过在十几天前参加完<strong>腾讯云开发者大会</strong>回来之后，结合之后的各种计划，又改变了主意，准备把网站项目托管在coding上。</p><p>在这之前，考虑到github服务器在国外，有许多不确定因素，所以早就有过换用coding或者码云的想法，不过这两家都不是大公司，所以还是不太信任他们。</p><p>这次大会上有公布腾讯和coding的合作计划，coding升级成“腾讯云开发者平台”，有了腾讯爸爸背书，那么选择coding自然也就成了顺理成章的事儿了。</p><p>之后就是忙活各种杂活儿了，顺带还是没有抵挡住诱惑，搞了个.cf顶级域名。</p><h2 id="正式完工"><a href="#正式完工" class="headerlink" title="正式完工"></a>正式完工</h2><p>然后因为考试和其他事情就又搁置下了，结果今晚收到域名供应商的邮件，他们访问了我的域名发现还没有被启用，接下来几天他们会每天都来访问，如果还是没有启用，那么为了避免域名资源被浪费，他们会收回域名。。。。</p><p>于是就大晚上开始开工干活，建项目，从github克隆项目到本地的git仓库，再push到coding上新的远程仓库，然后部署，绑定自己的域名和dns服务器等等。</p><p>出来的效果基本上还是不错的，接下来就是完善内容和修改一些细节啦。</p><p>顺带，现在的dns服务器在国外，面对国内严重污染的dns环境可能有些无力，为了避免被运营商劫持或者其他dns污染的情况，还得找个时间换成国内的dns服务器。</p><p>另外，虽然.cf的顶级域名不错，但还是想要个.com的顶级域名，不过这个倒不是多重要，等以后把网站转到自己服务器上了再买吧。</p><p>以上。</p><hr><h2 id="2019-1-19更新："><a href="#2019-1-19更新：" class="headerlink" title="2019-1-19更新："></a>2019-1-19更新：</h2><p>已购买2年的<strong>.com</strong>顶级域名，并启用了<strong>https证书</strong>，换到了国内的DNS服务器。</p><p>现通过<a href="https://ranchoturing.com" target="_blank" rel="noopener">https://ranchoturing.com</a>及<a href="https://www.ranchoturing.com" target="_blank" rel="noopener">https://www.ranchoturing.com</a>均可访问博客网站，并且保留了原来的<a href="http://www.ranchoturing.cf" target="_blank" rel="noopener">http://www.ranchoturing.cf</a>。</p><hr><h2 id="2019-3-16更新："><a href="#2019-3-16更新：" class="headerlink" title="2019-3-16更新："></a>2019-3-16更新：</h2><p>因为发现coding的pages服务老是挂掉，所以昨晚连夜把博客从coding上迁移到了github上，本来很简单的事情，结果因为zz校园网硬是搞了好久。。。</p><p>移植到github之后，博客莫名其妙被校园网墙掉了，一直404，只能挂vpn或者手机开流量访问。。。</p><p>只能找时间去网络中心找人问下了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 网站建设 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
