<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="十大排序算法比较"><meta name="keywords" content="ACM,算法,排序"><meta name="author" content="Rancho Turing"><meta name="copyright" content="Rancho Turing"><title>十大排序算法比较 | Rancho's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8c71b8c5746412ffcaf1e2d2ec72d90e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0、简介"><span class="toc-number">1.</span> <span class="toc-text">0、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、相关概念"><span class="toc-number">2.</span> <span class="toc-text">1、相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、算法分类"><span class="toc-number">3.</span> <span class="toc-text">2、算法分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、各算法的时间复杂度"><span class="toc-number">4.</span> <span class="toc-text">3、各算法的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、排序算法的实现"><span class="toc-number">5.</span> <span class="toc-text">4、排序算法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0、通用函数及其他"><span class="toc-number">5.1.</span> <span class="toc-text">0、通用函数及其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1、冒泡排序"><span class="toc-number">5.2.</span> <span class="toc-text">1、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-0、简单冒泡排序"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.0、简单冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1、外层循环优化冒泡排序"><span class="toc-number">5.2.2.</span> <span class="toc-text">1.1、外层循环优化冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2、内层循环优化冒泡排序"><span class="toc-number">5.2.3.</span> <span class="toc-text">1.2、内层循环优化冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、快速排序"><span class="toc-number">5.3.</span> <span class="toc-text">2、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0、随机快速排序"><span class="toc-number">5.3.1.</span> <span class="toc-text">2.0、随机快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1、小和问题"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.1、小和问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0、插入排序"><span class="toc-number">5.4.</span> <span class="toc-text">3.0、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0、插入排序-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.0、插入排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、希尔排序"><span class="toc-number">5.5.</span> <span class="toc-text">4、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0、希尔排序"><span class="toc-number">5.5.1.</span> <span class="toc-text">4.0、希尔排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、选择排序"><span class="toc-number">5.6.</span> <span class="toc-text">5、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-0、选择排序"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.0、选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、堆排序"><span class="toc-number">5.7.</span> <span class="toc-text">6、堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0、堆排序"><span class="toc-number">5.7.1.</span> <span class="toc-text">6.0、堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、归并排序"><span class="toc-number">5.8.</span> <span class="toc-text">7、归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-0、二路归并排序"><span class="toc-number">5.8.1.</span> <span class="toc-text">7.0、二路归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、计数排序"><span class="toc-number">5.9.</span> <span class="toc-text">8、计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-0、计数排序"><span class="toc-number">5.9.1.</span> <span class="toc-text">8.0、计数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、桶排序"><span class="toc-number">5.10.</span> <span class="toc-text">9、桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-0、桶排序"><span class="toc-number">5.10.1.</span> <span class="toc-text">9.0、桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1、桶排序思想"><span class="toc-number">5.10.2.</span> <span class="toc-text">9.1、桶排序思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、基数排序"><span class="toc-number">5.11.</span> <span class="toc-text">10、基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-0、基数排序"><span class="toc-number">5.11.1.</span> <span class="toc-text">10.0、基数排序</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Rancho Turing</div><div class="author-info__description text-center">Rancho Turing 's Blog.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdna.artstation.com/p/assets/images/images/005/217/372/large/sylvain-sarrailh-vendome.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rancho's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">十大排序算法比较</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法学习/">算法学习</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 32 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h2><p> <a href="https://www.nowcoder.com/discuss/85719" target="_blank" rel="noopener">原作者：opooc</a></p>
<h2 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h2><p><strong>时间复杂度：</strong></p>
<blockquote>
<p>反映当数据量变化时，操作次数的多少;时间复杂度在评估时，要只保留最高项，并且不要最高项的系数。(下面用logN表示 log以2为底，N的对数)     </p>
</blockquote>
<p><strong>空间复杂度：</strong></p>
<blockquote>
<p>是指算法在计算机内执行时，所需额外开辟的空间。     </p>
</blockquote>
<p><strong>指标：</strong> </p>
<blockquote>
<p>同时间复杂度。     </p>
</blockquote>
<p><strong>常数项：</strong></p>
<blockquote>
<p>与N的大小无关的操作。     </p>
</blockquote>
<p><strong>稳定性：</strong></p>
<blockquote>
<p>(1)稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>(2)不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。     </p>
</blockquote>
<h2 id="2、算法分类"><a href="#2、算法分类" class="headerlink" title="2、算法分类"></a>2、算法分类</h2><blockquote>
<p><strong>十大经典排序算法可以分为两大类：</strong><br>0、非线性时间排序：通过比较来决定元素间的相对次序。时间复杂度最快为O(logN)<br>1、线性时间排序：通过创建有序的空间，将元素按照一定的规则放入有序空间，再依次取出。以空间来换取时间，可以突破O(logN)     </p>
</blockquote>
<ul>
<li>非线性时间排序         <ol>
<li>比较排序                 <ul>
<li>冒泡排序                     </li>
<li>快速排序                     </li>
</ul>
</li>
<li>插入排序                 <ul>
<li>插入排序                     </li>
<li>希尔排序                     </li>
</ul>
</li>
<li>选择排序                 <ul>
<li>选择排序                     </li>
<li>堆排序                     </li>
</ul>
</li>
<li>归并排序                 <ul>
<li>二路归并排序                     </li>
<li>多路归并排序                     </li>
</ul>
</li>
</ol>
</li>
<li>线性时间排序         <ol>
<li>计数排序             </li>
<li>堆排序             </li>
<li>基数排序             </li>
</ol>
</li>
</ul>
<h2 id="3、各算法的时间复杂度"><a href="#3、各算法的时间复杂度" class="headerlink" title="3、各算法的时间复杂度"></a>3、各算法的时间复杂度</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最好)</th>
<th>空间复杂度</th>
<th style="text-align:left">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>冒泡排序(外层优化)</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(N)</td>
<td>O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>冒泡排序(外+内优化)</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(N)</td>
<td>O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>快速排序(经典)</td>
<td>O(NlogN)</td>
<td>O(N2)</td>
<td>O(NlogN)</td>
<td>O(logN)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td>快速排序(随机)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(logN)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(N)</td>
<td>O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(N^(1.3))</td>
<td>O(N2)</td>
<td>O(N)</td>
<td>O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(N2)</td>
<td>O(1)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(1)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td>二路归并排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>多路路归并排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(N+k)</td>
<td>O(N+k)</td>
<td>O(N+k)</td>
<td>O(N+k)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(N+k)</td>
<td>O(N2)</td>
<td>O(N+k)</td>
<td>O(N+k)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(N∗k)</td>
<td>O(N∗k)</td>
<td>O(N∗k)</td>
<td>O(N+k)</td>
<td style="text-align:left">稳定</td>
</tr>
</tbody>
</table>
<h2 id="4、排序算法的实现"><a href="#4、排序算法的实现" class="headerlink" title="4、排序算法的实现"></a>4、排序算法的实现</h2><h3 id="0、通用函数及其他"><a href="#0、通用函数及其他" class="headerlink" title="0、通用函数及其他"></a>0、通用函数及其他</h3><blockquote>
<p>(0)、求数组长度（需要传数组，不要传数组指针）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里的注意点：在计算数组大小的时候，</span></span><br><span class="line"><span class="comment">   一定要注意传入的数组是否为数组指针，</span></span><br><span class="line"><span class="comment">   如果传入的是数组指针，sizeof后出来的值为8(64位下)，读者应注意。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(T&amp;amp; arr)</span></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(1)、交换数组两个数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangee</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="comment">/*   ^符号 即”异或“运算符，特点是与0异或，</span></span><br><span class="line"><span class="comment">  保持原值；与本身异或，结果为0。</span></span><br><span class="line"><span class="comment"> 这里可以使用位运算，交换时不用开辟额外空间。</span></span><br><span class="line"><span class="comment">  但是如果传入的'位置相同'的两个数，就不能在此函数中进行交 </span></span><br><span class="line"><span class="comment">  换。因为，自己跟自己异或后结果一定为0,就没有什么意义了。</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[b] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">//arr[a] = arr[a] ^ arr[b];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[a];</span><br><span class="line">arr[a] =  arr[b];</span><br><span class="line">arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p> (2)、算法中的表达<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A代表平均时间复杂度</span><br><span class="line">* B代表最坏时间复杂度</span><br><span class="line">* E代表最好时间复杂度</span><br><span class="line">* 省略了O()</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(3)、大数据样本下四钟最快算法的比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 数据是随机整数，时间单位是秒</span></span><br><span class="line"><span class="comment"> 数据规模|快速排序 归并排序 希尔排序 堆排序</span></span><br><span class="line"><span class="comment"> 1000万 |  0.75  1.221.773.57</span></span><br><span class="line"><span class="comment"> 5000万 |  3.78  6.299.4826.54</span></span><br><span class="line"><span class="comment"> 1亿|  7.65  13.06   18.79   61.31</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(4)、时间复杂度的大小比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> N!&gt;; x^N &gt;;...&gt;;3^N &gt;;2^N &gt;; N^x&gt;;...&gt;;N^3 &gt;;N^2&gt;;NlogN&gt;;N&gt;;logN&gt;;1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(5)数组和数组大小的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arrAndSize</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(6)初始化数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//一维 每个元素初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](<span class="number">0</span>);</span><br><span class="line"><span class="comment">//二维 每个元素都没有初始化</span></span><br><span class="line"><span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//二维 每个一维中含N个数，N为确定的数值。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(N);</span><br><span class="line"><span class="comment">//通过动态创建的数组，要进行内存释放，否则内存将泄漏</span></span><br><span class="line"><span class="comment">//(本文中，未进行内存释放)</span></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(7)综合排序总结</p>
<ul>
<li>思考一个排序时候，考虑时间复杂度中的指标和常数项，空间复杂度，稳定性.</li>
</ul>
</blockquote>
<ul>
<li><p>代码规模，一定程度上说明了常数项的大小。（最终常数项的大小是看发生常数操作的次数）</p>
</li>
<li><p>系统的sort 方法，发现传进来的值为数值型，会使用快排，如果发现传的还有比较器，会使用归并排序</p>
</li>
<li><p><strong>归并和快排哪种更快？</strong><br>快排比归并排序的常数项要低，所以要快。</p>
</li>
<li><p><strong>为什么会有归并和快排两种呢？</strong><br>在比较的时候，使用比较器的时候，要追求一个稳定性，使用 归并排序 可以达稳定性的效果；使用快排不能够实现稳定性的效果。</p>
</li>
<li><p>面对大规模的时候，当排序量是小于等于60的时候，sort方法  会在内部使用插入排序的方法（不一定是60，是一定的规模）当数据量很低的时候，插入排序的常数项低。</p>
</li>
<li><p>在c语言中有一版，把归并排序，改成非递归，是基于工程其他考虑。</p>
</li>
</ul>
<blockquote>
<p>(8)对比两个数组是否相同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span> firstArr[],<span class="keyword">int</span> Second[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second != <span class="literal">nullptr</span>) ||(firstArr != <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (firstArr == <span class="literal">nullptr</span> &amp;amp;&amp;amp; Second == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len(firstArr) != len(Second)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len(firstArr); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (firstArr[i] != Second[i]) &#123;</span><br><span class="line"><span class="comment">//可以在此位置，打印错误项</span></span><br><span class="line"><span class="comment">//也可以打印整个数组查看错误项</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(9)复制数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">arrayCopy</span><span class="params">(<span class="keyword">int</span> oldArray[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oldArray == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* newArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i&lt;;length;i++) &#123;</span><br><span class="line">newArray[i] = oldArray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(10)产生随机数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arrAndSize <span class="title">generateRandomArr</span><span class="params">(<span class="keyword">int</span> maxSize,<span class="keyword">int</span> maxValue)</span></span>&#123;</span><br><span class="line"><span class="comment">//int arrrr =rand()%10;</span></span><br><span class="line">arrAndSize aAndS;</span><br><span class="line"><span class="keyword">int</span> size = (<span class="keyword">int</span>)((maxSize+<span class="number">1</span>) * (rand()%<span class="number">10</span>/(<span class="keyword">double</span>)<span class="number">10</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;;<span class="string">"&#123;"</span>&lt;;&lt;;size&lt;;&lt;;<span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt;; size;i++)&#123;</span><br><span class="line"><span class="comment">// 随机生成[-N,N];</span></span><br><span class="line"><span class="comment">//array[i] = (int)((maxValue +1) * (rand()%100)/(double)100) - (int)((maxValue + 1) * (rand()%100/(double)100));</span></span><br><span class="line"><span class="comment">//随机生成[0,N];</span></span><br><span class="line"> <span class="built_in">array</span>[i] = (<span class="keyword">int</span>)((maxValue +<span class="number">1</span>) * (rand()%<span class="number">10</span>)/(<span class="keyword">double</span>)<span class="number">10</span>);</span><br><span class="line"><span class="comment">//打印到底生成了什么。</span></span><br><span class="line"><span class="comment">//cout&lt;;&lt;;i&lt;;&lt;;"===="&lt;;&lt;;array[i] &lt;;&lt;;"|";</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;;&lt;;"+++++"&lt;;&lt;;endl;</span></span><br><span class="line">aAndS.size = size;</span><br><span class="line">aAndS.<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">return</span> aAndS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(11)疯狂递归 -递归master公式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 递归master公式</span></span><br><span class="line"><span class="comment"> T(N)的公式从大规模来看，不细分。</span></span><br><span class="line"><span class="comment"> T(N) = a * T(N/b)+O(n^d)</span></span><br><span class="line"><span class="comment"> N/b 是子过程数据量 ；a是子过程调用多少次；O(n^d)是出去</span></span><br><span class="line"><span class="comment"> 过程之外剩下的数据量的多少</span></span><br><span class="line"><span class="comment"> if log(b)a &gt;; d =&gt;; O(N^log(b)a)</span></span><br><span class="line"><span class="comment"> if log(b)a = d =&gt;; O(N^d *logN)</span></span><br><span class="line"><span class="comment"> if log(b)a &lt;; d =&gt;; O(N^d)</span></span><br><span class="line"><span class="comment"> 注意 多个递归的规模必须一样，否则master公式失效。</span></span><br><span class="line"><span class="comment">  例如一个规模是1/3;一个是2/3;</span></span><br><span class="line"><span class="comment"> 以下算法的时间复杂度：a = 2;b = 2;d = 0;所以时间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> arr[] ,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L ==  R) &#123;<span class="comment">//base case;</span></span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> LeftMax = process(arr, L, mid);</span><br><span class="line"><span class="keyword">int</span> RightMax = process(arr, mid+<span class="number">1</span> , R);</span><br><span class="line"><span class="keyword">return</span> (LeftMax /RightMax)?LeftMax  : RightMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInArray</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> process(arr , <span class="number">0</span> , length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>(12)比较器</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按照年龄降序比较器</span></span><br><span class="line"><span class="comment"> 比较器使用的时候 不和java一样，c++中的比较器要注意返回值要为bool类型，</span></span><br><span class="line"><span class="comment">  而java中的返回值可以为int类型，根据两数相减进行判断下一步的排序。</span></span><br><span class="line"><span class="comment"> 比较器第一次比较完成后，下一次在比较的时候还是会含有第一次的排号的顺序，</span></span><br><span class="line"><span class="comment">  是利用了c++中sort函数的排序稳定性.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//比较器的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> classId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照年龄升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallAge</span><span class="params">(student s1,student s2)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里返回false的时候，相当于进行了一个交换操作</span></span><br><span class="line"><span class="keyword">return</span> s2.age &gt;; s1.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照班级升序比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareSmallClassId</span><span class="params">(student s1, student s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s2.classId &gt;; s1.classId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">student s1 =  &#123;<span class="string">"opooc"</span>,<span class="number">21</span>,<span class="number">100</span>&#125;;</span><br><span class="line">student s2 =  &#123;<span class="string">"cat"</span>,<span class="number">30</span>,<span class="number">105</span>&#125;;</span><br><span class="line">student s3 =  &#123;<span class="string">"dog"</span>,<span class="number">1</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s4 =  &#123;<span class="string">"daolao"</span>,<span class="number">2</span>,<span class="number">107</span>&#125;;</span><br><span class="line">student s5 =  &#123;<span class="string">"dst"</span>,<span class="number">20</span>,<span class="number">103</span>&#125;;</span><br><span class="line">student allStudent[] =&#123;s1,s2,s3,s4,s5&#125;;</span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallAge);</span><br><span class="line"><span class="comment">//上面按照年龄升序后的结果，会继续在下面的班级降序中体现出来</span></span><br><span class="line">sort(allStudent, allStudent+<span class="number">5</span>, compareSmallClassId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(13)vector容器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个一维容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;; v;</span><br><span class="line"><span class="comment">//声明一个二维数组，里面每个一维数组大小为10(必填)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; v1[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除最后添加的元素</span></span><br><span class="line">v.pop_back();</span><br><span class="line"><span class="comment">//删除向量中迭代器指向元素</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除向量中[first,last)中元素 如下删除1234位置</span></span><br><span class="line">v.erase(v.begin()+<span class="number">1</span>,v.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在第零个元素前面插1</span></span><br><span class="line">v.insert(v.begin(),<span class="number">1</span>);</span><br><span class="line"><span class="comment">//在第二个元素前插2</span></span><br><span class="line">v.insert(v.begin()+<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在最后一个元素后面插的10</span></span><br><span class="line">v.insert(v.end(),<span class="number">10</span>);</span><br><span class="line"><span class="comment">//元素的个数</span></span><br><span class="line">v.size();</span><br><span class="line"><span class="comment">//清除所有元素</span></span><br><span class="line">v.clear();</span><br><span class="line"><span class="comment">//遍历整个数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;:: iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;;&lt;; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>算法描述:</p>
<blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<p>动画演示:</p>
<p><img alt="冒泡排序" src="https://img-blog.csdn.net/20180711042751164?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p>
</blockquote>
<h4 id="1-0、简单冒泡排序"><a href="#1-0、简单冒泡排序" class="headerlink" title="1.0、简单冒泡排序"></a>1.0、简单冒泡排序</h4><blockquote>
<p>（交换排序;时间A:N^2 ,B:N^2 ,E:N^2 ;空间1;稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;;length - i; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j]&gt;;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">			exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="1-1、外层循环优化冒泡排序"><a href="#1-1、外层循环优化冒泡排序" class="headerlink" title="1.1、外层循环优化冒泡排序"></a>1.1、外层循环优化冒泡排序</h4><blockquote>
<p>(交换排序; 时间A:N^2 , B:N^2 , E:N; 空间1; 稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用一个flag来判断一下，当前数组是否已经有序,</span></span><br><span class="line"><span class="comment">  有序就退出循环，可以提高冒泡排序的性能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;;length; i++) &#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; length -i; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[j]&gt;;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">			exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">			flag  =<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="1-2、内层循环优化冒泡排序"><a href="#1-2、内层循环优化冒泡排序" class="headerlink" title="1.2、内层循环优化冒泡排序"></a>1.2、内层循环优化冒泡排序</h4><blockquote>
<p>(交换排序; 时间A:N^2 , B:N^2 , E:N ; 空间1 ; 稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)完美冒泡</span></span><br><span class="line"><span class="comment">(2)再用last标记一下最后一个发生交换的数，</span></span><br><span class="line"><span class="comment">   下次可以减少循环次数。其中第一次内部循环的控制条件，单独拿出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>算法描述:</p>
<blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<p>动画演示:<br><img alt="快速排序" src="https://img-blog.csdn.net/20180711042825711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法流程如下：<br>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</blockquote>
<h4 id="2-0、随机快速排序"><a href="#2-0、随机快速排序" class="headerlink" title="2.0、随机快速排序"></a>2.0、随机快速排序</h4><blockquote>
<p>（交换排序;时间A:NlogN,B:NlogN,E:NlogN;空间logN;不稳定）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (1)in-place原地算法可以实现 把以划分值为标准，</span></span><br><span class="line"><span class="comment">       小于等于划分值的放左边并推着大于划分值的数向右走。</span></span><br><span class="line"><span class="comment">       时间复杂度O(N)空间复杂度是O（1）</span></span><br><span class="line"><span class="comment">    (2)（荷兰国旗问题）在实现把等于划分值的放中间，小于</span></span><br><span class="line"><span class="comment">        划分值的放左边，大于划分值的放右边且时间复杂度O(N)</span></span><br><span class="line"><span class="comment">        空间复杂度仍未O(1)的时候。1.当前数&lt;p左区下一个</span></span><br><span class="line"><span class="comment">        交换，左区扩，检测下一个。2、当前数等于p，检测下</span></span><br><span class="line"><span class="comment">        一个。3、当前数大于p，和右区前一个位置换，右区扩。</span></span><br><span class="line"><span class="comment">        继续检测当前换完的数。</span></span><br><span class="line"><span class="comment">    (3) 其中的空间复杂度是不得不使用的空间，用来记录每次的左右边界。</span></span><br><span class="line"><span class="comment">    (4)快速排序可以做到稳定，但是非常难，可以搜 0-1stable sort论文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">separate</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first  = left <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Second = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; Second) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]&lt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, ++first, left++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">            exchangee(arr, --Second, left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]==arr[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exchangee(arr, Second, right);</span><br><span class="line">    <span class="keyword">int</span> firstAndSecond[<span class="number">2</span>] = &#123;first+<span class="number">1</span>,Second&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> firstAndSecond;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> randomC = (<span class="keyword">int</span>)((rand()%<span class="number">100</span>/(<span class="keyword">double</span>)<span class="number">100</span>) * (right - left +<span class="number">1</span>));</span><br><span class="line">        exchangee(arr,left+ randomC, right);</span><br><span class="line">        <span class="keyword">int</span>* curArr  = separate(arr, left, right);</span><br><span class="line">        quickSort(arr, left,curArr[<span class="number">0</span>] <span class="number">-1</span> );</span><br><span class="line">        quickSort(arr, curArr[<span class="number">1</span>]+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>]=&#123;<span class="number">99</span>,<span class="number">11</span>,<span class="number">72</span>,<span class="number">62</span>,<span class="number">53</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">21</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = len(arr);</span><br><span class="line">    quickSort(arr,length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-1、小和问题"><a href="#2-1、小和问题" class="headerlink" title="2.1、小和问题"></a>2.1、小和问题</h4><p>问题描述</p>
<blockquote>
<p>求小和问题：在随机元素，随机数组大小的数组中，找出左边比右边元素小的所有元素之和。<br>例如：数组[4,2,5,1,7,3,6] 第一个元素4比2大，不算小和，5比4和2都大，那就是4+2=6；1比4和2和5都小，不算小和；7比前面的都大，那就是上次小和6+4+2+5+1=18；然后3前面比2和1大，那就是18+2+1=21；最后6比4、2、5、1、3都大，结果就是21+4+2+5+1+3=36。那么最后的结果就是36。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小和问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> *help = <span class="keyword">new</span> <span class="keyword">int</span>(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;=mid &amp;&amp; pSecond &lt;=R) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在左右两个区有谁小谁移动的原则</span></span><br><span class="line"><span class="comment">        看小和问题和逆序对问题时，要抓住一边分析。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">      （小和问题，因为要统计左区小于右区的数的数量，</span></span><br><span class="line"><span class="comment">      既统计左区比右区小的数，因为在排序的时候，左区可能会移动，</span></span><br><span class="line"><span class="comment">      故左区在移动后，无法在下一步查看右区大于的数，</span></span><br><span class="line"><span class="comment">      所以要一次性把针对左区当前数大的数全部记录下来</span></span><br><span class="line"><span class="comment">        逆序对问题，则需要一个一个记录左区比右区大的数。）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sum += arr[pFirst] &lt; arr[pSecond] ? arr[pFirst]*(R-pSecond+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">        help[i++]  = arr[pFirst] &lt; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;= mid ) &#123;</span><br><span class="line">        help[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (R-L+<span class="number">1</span>); k++) &#123;</span><br><span class="line">        arr[L+k] = help[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L==R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>  mid = L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">//  相当于  int  mid = L+(R-L)/2;</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = smallSum(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightSum = smallSum(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">int</span> leftAndRightSum = allSum(arr,L,mid,R);</span><br><span class="line">    <span class="keyword">return</span>  leftSum + rightSum + leftAndRightSum;</span><br><span class="line"><span class="comment">//    return smallSum(arr, L, mid)+smallSum(arr, mid + 1, R)+allSum(arr,L,mid,R);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span> <span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">nullptr</span> || length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum(arr,<span class="number">0</span>,length <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-0、插入排序"><a href="#3-0、插入排序" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h3><p>算法描述:</p>
<blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
</blockquote>
<p>动画演示:<br><img alt="插入排序" src="https://img-blog.csdn.net/20180711042900649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法流程如下：<br>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；<br>重复步骤2~5。</p>
</blockquote>
<h4 id="3-0、插入排序-1"><a href="#3-0、插入排序-1" class="headerlink" title="3.0、插入排序"></a>3.0、插入排序</h4><blockquote>
<p>(插入排序;时间A:N^2 , B:N^2 , E:N;空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、在对比的时候不交换；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;; length;i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span>&amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以直接交换。因为current记录了最后一个值，</span></span><br><span class="line"><span class="comment">            所以这里使用向后移动思想。</span></span><br><span class="line"><span class="comment">            exchangee(arr, preIndex, current);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex --;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法二、在对比的时候进行交换；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;length ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j&gt;;=<span class="number">0</span> &amp;amp;&amp;amp; arr[j]&gt;;arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exchangee(arr, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h3><p>算法描述:</p>
<blockquote>
<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
</blockquote>
<p>动画演示:<br><img alt="希尔排序" src="https://img-blog.csdn.net/20180711042930449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法流程：<br>选择一个增量序列t1，t2，…，tk，其中ti&gt;;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</blockquote>
<h4 id="4-0、希尔排序"><a href="#4-0、希尔排序" class="headerlink" title="4.0、希尔排序"></a>4.0、希尔排序</h4><blockquote>
<p>(插入排序;时间A:N^1.3 , B:N^2 , E:N;空间1;不稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (又称缩小增量排序)</span></span><br><span class="line"><span class="comment">    通过实验，大量本表现出，平均时间复杂度为N^1.3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> gap = length;</span><br><span class="line">    <span class="keyword">while</span> (gap&gt;;<span class="number">1</span>)&#123;</span><br><span class="line">        gap = gap/<span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i&lt;;length; i+=gap) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;;= <span class="number">0</span> &amp;amp;&amp;amp; arr[preIndex]&gt;;current) &#123;</span><br><span class="line">                arr[i]  = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex+gap] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h3><p>算法描述:</p>
<blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<p>动画演示:<br><img alt="选择排序" src="https://img-blog.csdn.net/20180711042950325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>实现逻辑:</p>
<blockquote>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法流程如下：<br>初始状态：无序区为R[1..n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p>
</blockquote>
<h4 id="5-0、选择排序"><a href="#5-0、选择排序" class="headerlink" title="5.0、选择排序"></a>5.0、选择排序</h4><blockquote>
<p>(选择排序;时间A:N^2 , B:N^2 , E:N^2 ; 空间1;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;length<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;   <span class="keyword">int</span> minIndex =i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;;length;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;;arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h3><p>算法描述:</p>
<blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>动画演示:<br><img alt="堆排序" src="https://img-blog.csdn.net/20180711043016142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
</blockquote>
<p>实现逻辑:</p>
<blockquote>
<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
</blockquote>
<h4 id="6-0、堆排序"><a href="#6-0、堆排序" class="headerlink" title="6.0、堆排序"></a>6.0、堆排序</h4><blockquote>
<p>(选择排序;时间A:NlogN,B:NlogN,E:NlogN;空间1;不稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">        堆的概念：对于大根堆，其子树下的所有节点，</span><br><span class="line">     包括它自己在内的最大值为头结点。</span><br><span class="line">        时间复杂度为0+log1+log2+……数学上可以证明</span><br><span class="line">     这个值收敛于O(N)</span><br><span class="line">*/</span><br><span class="line">//向上走</span><br><span class="line">void heapInsert(int arr[],int index)&#123;</span><br><span class="line">    while (arr[index] &gt;; arr[(index-1)/2]) &#123;</span><br><span class="line">        exchangee(arr,index, (index-1)/2);</span><br><span class="line">        index = (index -1)/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//向下走</span><br><span class="line">//size为最右的边界，size是取不到的.</span><br><span class="line">void heapify(int arr[],int index ,int size)&#123;</span><br><span class="line">    int leftChild = index*2 + 1;</span><br><span class="line">    while (leftChild &lt;; size) &#123;</span><br><span class="line">        int maxChild = leftChild + 1 &lt;; size &amp;amp;&amp;amp; arr[leftChild+1] &gt;;arr[leftChild] ? leftChild+1 : leftChild;</span><br><span class="line">        int maxAll = arr[maxChild] &gt;; arr[index] ? maxChild: index;</span><br><span class="line">        if (maxAll  == index) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        exchangee(arr, maxAll, index);</span><br><span class="line">        index = maxAll;</span><br><span class="line">        leftChild = index*2 +1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i = 0;i &lt;;length;i++)&#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    int size = length;</span><br><span class="line">    exchangee(arr, 0, --size);</span><br><span class="line">    while (size &gt;; 0)&#123;</span><br><span class="line">        //heapify时间复杂度为O(logN)</span><br><span class="line">        heapify(arr, 0, size);</span><br><span class="line">        exchangee(arr, 0, --size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><p>算法描述:</p>
<blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<p>动画演示:<br><img alt="归并排序" src="https://img-blog.csdn.net/20180711043050105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p>
</blockquote>
<h4 id="7-0、二路归并排序"><a href="#7-0、二路归并排序" class="headerlink" title="7.0、二路归并排序"></a>7.0、二路归并排序</h4><blockquote>
<p>(插入排序;时间A:N<em>logN,B:N</em>logN,E:N*logN;空间N;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    归并排序内部缓存法 可以把空间复杂度降到O(1)；</span></span><br><span class="line"><span class="comment">    归并排序原地归并法 也可以把空间复杂度降到O(1)但是时间复</span></span><br><span class="line"><span class="comment">    杂度会变成O(N^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> M,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* cent = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pFirst = L;</span><br><span class="line">    <span class="keyword">int</span> pSecond = M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M &amp;amp;&amp;amp; pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst] &lt;; arr[pSecond] ? arr[pFirst++]:arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pFirst &lt;;= M) &#123;</span><br><span class="line">        cent[i++] = arr[pFirst++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pSecond &lt;;= R) &#123;</span><br><span class="line">        cent[i++] = arr[pSecond++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; (R-L+<span class="number">1</span>); j++) &#123;</span><br><span class="line">        arr[L+j] = cent[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, L, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">nullptr</span> || length&lt;;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(<span class="built_in">array</span>,<span class="number">0</span>,length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h3><p>算法描述:</p>
<blockquote>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<p>动画演示:<br><img alt="计数排序" src="https://img-blog.csdn.net/20180711043148643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>对所有的计数累加(从桶中的第0个元素开始，每一项和前一项相加);<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项,<br>每放一个元素就将C(i)减去1，是为了保证算法的稳定性。</p>
</blockquote>
<h4 id="8-0、计数排序"><a href="#8-0、计数排序" class="headerlink" title="8.0、计数排序"></a>8.0、计数排序</h4><blockquote>
<p>(计数排序;时间A:N+k,B:N+k,E:N+k;空间N+k;稳定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*    输入的元素是 n 个 0到 k 之间的整数</span><br><span class="line">      当k不是很大并且序列比较集中时，计数排序是一个很有效的</span><br><span class="line">   排序算法。</span><br><span class="line">      下面算法是输入的数组中的最小值大于等于0的情况，</span><br><span class="line">   可以根据需求更改。    </span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">void countSort(int arr[] ,int length)&#123;</span><br><span class="line">    int max = arr[0];</span><br><span class="line">    int lastIndex=  0;</span><br><span class="line">    for (int i = 1; i&lt;;length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    int* sortArr  = new int[max+1]();</span><br><span class="line">    for (int j = 0; j&lt;; length; j++) &#123;</span><br><span class="line">        sortArr[arr[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int k = 0; k&lt;;max+1; k++) &#123;</span><br><span class="line">        while (sortArr[k]&gt;;0) &#123;</span><br><span class="line">            arr[lastIndex++] = k;</span><br><span class="line">            sortArr[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h3><p>算法描述:</p>
<blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
</blockquote>
<p>图片演示:<br><img alt="桶排序" src="https://img-blog.csdn.net/201807110432136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。</p>
</blockquote>
<h4 id="9-0、桶排序"><a href="#9-0、桶排序" class="headerlink" title="9.0、桶排序"></a>9.0、桶排序</h4><blockquote>
<p>桶排序(时间A:N+k,B:N^2,E:N+k;空间N+k;稳定)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序是: 桶思想排序 + 一个普通的排序（常用快速排序）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark bucketSort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//size  为一个桶的囊括的数的范围</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到最大最小值</span></span><br><span class="line">    <span class="keyword">long</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">long</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i] &lt;; min ? arr[i]: min;</span><br><span class="line">        max = arr[i] &gt;; max ? arr[i]: max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最小值等于最大值说明数组中就一种数</span></span><br><span class="line">    <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>)((max -min)/size +<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;;<span class="built_in">vector</span>&lt;;<span class="keyword">int</span>&gt;;&gt;; bucket(bucketCount);</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把数组中的数 扔进桶里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;  i &lt;; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        bid = getGroupCount(arr[i], bucketCount, min, max);</span><br><span class="line">        bucket[bid].push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;; bucketCount; i++) &#123;</span><br><span class="line">        <span class="comment">//对桶内进行插入排序。按照升序，这样可以保证从下往上读的稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (bucket[i][j] &lt;; bucket[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(bucket[i][j],bucket[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;; bucket[i].size(); t++) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;;&lt;;bucket[i][t]&lt;;&lt;;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    int *newArr = new int[len];</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;;bucketCount ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;;bucket[i].size(); j++) &#123;</span><br><span class="line">            arr[index++] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="9-1、桶排序思想"><a href="#9-1、桶排序思想" class="headerlink" title="9.1、桶排序思想"></a>9.1、桶排序思想</h4><p>问题描述</p>
<blockquote>
<p>数组最大值问题。<br>给定一个无序数组，求如果排序之后，相邻两数的最大差值，<br>要求时间复杂度O（N），且要求不能用基于比较的排序。<br>以此题发现桶排序妙趣思想.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     映射函数getGroupCount是得到在第几个桶，其能保证第一</span></span><br><span class="line"><span class="comment">  个桶有整个数组的最小值和最后一个桶有整个数组的最大值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroupCount</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> size ,<span class="keyword">long</span> min ,<span class="keyword">long</span> max )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)((size<span class="number">-1</span>)*(num - min)/(max - min));</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxGroup</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">//拿到系统的最大值和系统的最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;;len; i++) &#123;</span><br><span class="line">        min = arr[i]&lt;;min ? arr[i]:min;</span><br><span class="line">        max = arr[i]&gt;;max ? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* maxValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>* minValue =<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span>* flag = <span class="keyword">new</span> <span class="keyword">bool</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;;len; j++) &#123;</span><br><span class="line">        bid = getGroupCount(arr[j], len, min, max);</span><br><span class="line">        minValue[bid] = minValue[bid]? (minValue[bid]&lt;;arr[j]?minValue[bid]:arr[j]):arr[j];</span><br><span class="line">        maxValue[bid] = maxValue[bid]? (maxValue[bid]&gt;;arr[j]?maxValue[bid]:arr[j]):arr[j];</span><br><span class="line">        flag[bid] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k= <span class="number">1</span> ; k&lt;;len+<span class="number">1</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[k]) &#123;</span><br><span class="line">            res = res &gt;; (minValue[k] - maxValue[lastMax]) ? res :(minValue[k] - maxValue[lastMax]);</span><br><span class="line">            lastMax =k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h3><p>算法描述:</p>
<blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
</blockquote>
<p>动画演示:<br><img alt="基数排序" src="https://img-blog.csdn.net/20180711043311284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29wb29j/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> </p>
<p>实现逻辑:</p>
<blockquote>
<p>取得数组中的最大数，并取得位数；&lt;br /<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
</blockquote>
<h4 id="10-0、基数排序"><a href="#10-0、基数排序" class="headerlink" title="10.0、基数排序"></a>10.0、基数排序</h4><blockquote>
<p>(基数排序;时间A:N <em> k , B:N </em> k , E:N * k ; 空间N+k ; 稳定)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到传入数的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRadixCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count /<span class="number">10</span> &gt;;<span class="number">0</span>) &#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到10的传入位数的次方(10^num)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTenRadixCount</span><span class="params">(<span class="keyword">int</span> radixCount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tenRadix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (radixCount &gt;; <span class="number">0</span> ) &#123;</span><br><span class="line">        tenRadix *= <span class="number">10</span>;</span><br><span class="line">        radixCount --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tenRadix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;; length; i++) &#123;</span><br><span class="line">        max = arr[i]&gt;;max? arr[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> radixCount = getRadixCount(max);</span><br><span class="line">    <span class="keyword">int</span> tenRadixCount = getTenRadixCount(radixCount);</span><br><span class="line">    <span class="keyword">int</span> (*bucket)[<span class="number">10</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>* num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();</span><br><span class="line">    <span class="keyword">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (multiplier &lt;; tenRadixCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curCount = arr[i]/multiplier%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> k = num[curCount];</span><br><span class="line">            bucket[curCount][k] = arr[i];</span><br><span class="line">            num[curCount]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">0</span>; k&lt;;num[j]; k++) &#123;</span><br><span class="line">                    arr[index++]  =  bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把桶清空，准备下一次循环。</span></span><br><span class="line">            num[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        multiplier *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rancho Turing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://RanchoTuring.github.io/2019/04/11/排序算法/">http://RanchoTuring.github.io/2019/04/11/排序算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://RanchoTuring.github.io">Rancho's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ACM/">ACM</a><a class="post-meta__tags" href="/tags/算法/">算法</a><a class="post-meta__tags" href="/tags/排序/">排序</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/05/MySQL基础入门/"><i class="fa fa-chevron-left">  </i><span>MySQL基础知识入门</span></a></div><div class="next-post pull-right"><a href="/2019/04/11/python笔记/"><span>Python语法学习</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdna.artstation.com/p/assets/images/images/005/217/372/large/sylvain-sarrailh-vendome.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By Rancho Turing</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ranchoturing.com">blog</a>!</div><div class="icp"><a><span>京ICP备19048096号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">站内搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章及内容"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>